{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>\\ FROM SIGPLAN NOTICES, 21(12):158-166, December 1986. \u00a9\u00a0D.A.Turner\\</p>"},{"location":"#an-overview-of-miranda","title":"An Overview of Miranda","text":"<p>David Turner\\ Computing Laboratory\\ University of Kent\\ Canterbury CT2 7NF\\ ENGLAND</p> <p>Miranda is an advanced functional programming system which runs under the UNIX operating system (*). The aim of the Miranda system is to provide a modern functional language, embedded in a convenient programming environment, suitable both for teaching and as a general purpose programming tool. The purpose of this short article is to give a brief overview of the main features of Miranda. The topics we shall discuss, in order, are:</p> <ul> <li>Basic ideas</li> <li>The Miranda programming environment</li> <li>Guarded equations and block structure</li> <li>Pattern matching</li> <li>Currying and higher order functions</li> <li>List comprehensions</li> <li>Lazy evaluation and infinite lists</li> <li>Polymorphic strong typing</li> <li>User defined types</li> <li>Type synonyms</li> <li>Abstract data types</li> <li>Separate compilation and linking</li> <li>Current implementation status</li> </ul> <p>(*) [Note]{.underline}: UNIX is a trademark of AT&amp;T Bell Laboratories, Miranda is a trademark of Research Software Ltd. []{#Basic}</p>"},{"location":"#basic-ideas","title":"Basic ideas","text":"<p>The Miranda programming language is purely functional - there are no side effects or imperative features of any kind. A program (actually we don\\'t call it a program, we call it a \\\"script\\\") is a collection of equations defining various functions and data structures which we are interested in computing. The order in which the equations are given is not in general significant. There is for example no obligation for the definition of an entity to precede its first use. Here is a very simple example of a Miranda script:</p> <pre><code>        z = sq x / sq y\n        sq n = n * n\n        x = a + b\n        y = a - b\n        a = 10\n        b = 5\n</code></pre> <p>Notice the absence of syntactic baggage - Miranda is, by design, rather terse. There are no mandatory type declarations, although (see later) the language is strongly typed. There are no semicolons at the end of definitions - the parsing algorithm makes intelligent use of layout. Note that the notation for function application is simply juxtaposition, as in \\\"sq x\\\". In the definition of the sq function, \\\"n\\\" is a formal parameter - its scope is limited to the equation in which it occurs (whereas the other names introduced above have the whole script for their scope).</p> <p>The most commonly used data structure is the list, which in Miranda is written with square brackets and commas, e.g.:</p> <pre><code>        week_days = [\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\"]\n        days = week_days ++ [\"Sat\",\"Sun\"]\n</code></pre> <p>Lists may be appended by the \\\"++\\\" operator. Other useful operations on lists include infix \\\":\\\" which prefixes an element to the front of a list, \\\"#\\\" which takes the length of a list, and infix \\\"!\\\" which does subscripting. So for example 0:[1,2,3] has the value [0,1,2,3],</p>"},{"location":"#days-is-7-and-days0-is-mon","title":"days is 7, and days!0 is \\\"Mon\\\".","text":"<p>There is also an operator \\\"--\\\" which does list subtraction. For example [1,2,3,4,5] -- [2,4] is [1,3,5].</p> <p>There is a shorthand notation using \\\"..\\\" for lists whose elements form an arithmetic series. Here for example are definitions of the factorial function, and of a number \\\"result\\\" which is the sum of the odd numbers between 1 and 100 (sum and product are library functions):</p> <pre><code>        fac n = product [1..n]\n        result = sum [1,3..100]\n</code></pre> <p>The elements of a list must all be of the same type. A sequence of elements of mixed type is called a tuple, and is written using parentheses instead of square brackets. Example</p> <pre><code>        employee = (\"Jones\",True,False,39)\n</code></pre> <p>Tuples are analogous to records in Pascal (whereas lists are analogous to arrays). Tuples cannot be subscripted - their elements are extracted by pattern matching (see later). []{#Env}</p>"},{"location":"#the-programming-environment","title":"The programming environment","text":"<p>The Miranda system is interactive and runs under UNIX as a self contained subsystem. The basic action is to evaluate expressions, supplied by the user at the terminal, in the environment established by the current script. For example evaluating \\\"z\\\" in the context of the first script given above would produce the result \\\"9.0\\\".</p> <p>The Miranda compiler works in conjunction with an editor (by default this is \\\"vi\\\" but it can be set to any editor of the user\\'s choice). Scripts are automatically recompiled after edits, and any syntax or type errors signalled immediately. The polymorphic type system permits a high proportion of logical errors to be detected at compile time.</p> <p>There is quite a large library of standard functions. There is also an online reference manual. The interface to UNIX permits Miranda programs to take data from, and send data to, UNIX files and it is also possible to invoke Miranda programs directly from the UNIX shell and to combine them, via UNIX pipes, with processes written in other languages. []{#Guard}</p>"},{"location":"#guarded-equations-and-block-structure","title":"Guarded equations and block structure","text":"<p>An equation can have several alternative right hand sides distinguished by \\\"guards\\\" - the guard is written on the right following a comma. For example the greatest common divisor function can be written:</p> <pre><code>        gcd a b = gcd (a-b) b, if a&gt;b\n                = gcd a (b-a), if a&lt;b\n                = a,           if a=b\n</code></pre> <p>The last guard in such a series of alternatives can be written \\\"otherwise\\\", instead of \\\"if condition\\\", to indicate a default case(*).</p> <p>It is also permitted to introduce local definitions on the right hand side of a definition, by means of a \\\"where\\\" clause. Consider for example the following definition of a function for solving quadratic equations (it either fails or returns a list of one or two real roots):</p> <pre><code>        quadsolve a b c = error \"complex roots\",    if delta&lt;0\n                        = [-b/(2*a)],               if delta=0\n                        = [-b/(2*a) + radix/(2*a),\n                           -b/(2*a) - radix/(2*a)], if delta&gt;0\n                          where\n                          delta = b*b - 4*a*c\n                          radix = sqrt delta\n</code></pre> <p>Where clauses may occur nested, to arbitrary depth, allowing Miranda programs to be organised with a nested block structure. Indentation of inner blocks is compulsory, as layout information is used by the parser.</p> <p>(*) [Note]{.underline}: In early versions of Miranda the keyword \\\"if\\\" was not required. []{#Pattern}</p>"},{"location":"#pattern-matching","title":"Pattern matching","text":"<p>It is permitted to define a function by giving several alternative equations, distinguished by the use of different patterns in the formal parameters. This provides another method of doing case analysis which is often more elegant than the use of guards. We here give some simple examples of pattern matching on natural numbers, lists and tuples. Here is (another) definition of the factorial function, and a definition of Ackermann\\'s function:</p> <pre><code>        fac 0 = 1\n        fac (n+1) = (n+1) * fac n\n\n        ack 0 n = n+1\n        ack (m+1) 0 = ack m 1\n        ack (m+1) (n+1) = ack m (ack (m+1) n)\n</code></pre> <p>Here is a (naive) definition of a function for computing the n\\'th Fibonacci number:</p> <pre><code>        fib 0 = 0\n        fib 1 = 1\n        fib (n+2) = fib (n+1) + fib n\n</code></pre> <p>Here are some simple examples of functions defined by pattern matching on lists:</p> <pre><code>        sum [] = 0\n        sum (a:x) = a + sum x\n\n        product [] = 1\n        product (a:x) = a * product x\n\n        reverse [] = []\n        reverse (a:x) = reverse x ++ [a]\n</code></pre> <p>Accessing the elements of a tuple is also done by pattern matching. For example the selection functions on 2-tuples can be defined thus</p> <pre><code>        fst (a,b) = a\n        snd (a,b) = b\n</code></pre> <p>As final examples we give the definitions of two Miranda library functions, take and drop, which return the first n members of a list, and the rest of the list without the first n members, respectively</p> <pre><code>        take 0 x = []\n        take (n+1) [] = []\n        take (n+1) (a:x) = a : take n x\n\n        drop 0 x = x\n        drop (n+1) [] = []\n        drop (n+1) (a:x) = drop n x\n</code></pre> <p>Notice that the two functions are defined in such a way that that the following identity always holds - \\\"take\u00a0n\u00a0x\u00a0++\u00a0drop\u00a0n\u00a0x\u00a0=\u00a0x\\\" - including in the pathological case that the length of x is less than n. []{#Curry}</p>"},{"location":"#currying-and-higher-order-functions","title":"Currying and higher order functions","text":"<p>Miranda is a fully higher order language - functions are first class citizens and can be both passed as parameters and returned as results. Function application is left associative, so when we write \\\"f x y\\\" it is parsed as \\\"(f x) y\\\", meaning that the result of applying f to x is a function, which is then applied to y. The reader may test out his understanding of higher order functions by working out what is the value of \\\"answer\\\" in the following script:</p> <pre><code>        answer = twice twice twice suc 0\n        twice f x = f (f x)\n        suc x = x + 1\n</code></pre> <p>Note that in Miranda every function of two or more arguments is actually a higher order function. This is very useful as it permits partial application. For example \\\"member\\\" is a library function such that \\\"member x a\\\" tests if the list x contains the element a (returning True or False as appropriate). By partially applying member we can derive many useful predicates, such as</p> <pre><code>        vowel = member ['a','e','i','o','u']\n        digit = member ['0','1','2','3','4','5','6','7','8','9']\n        month = member [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"Jun\",\"Jul\",\"Aug\",\"Sep\", \n                        \"Oct\",\"Nov\",\"Dec\"]\n</code></pre> <p>As another example of higher order programming consider the function \\\"foldr\\\", defined</p> <pre><code>        foldr op k [] = k\n        foldr op k (a:x) = op a (foldr op k x)\n</code></pre> <p>All the standard list processing functions can be obtained by partially applying foldr. Examples</p> <pre><code>        sum = foldr (+) 0\n        product = foldr (*) 1\n        reverse = foldr postfix []\n                  where postfix a x = x ++ [a]\n</code></pre> <p>[]{#List}</p>"},{"location":"#list-comprehensions","title":"List comprehensions","text":"<p>List comprehensions give a concise syntax for a rather general class of iterations over lists. The syntax is adapted from an analogous notation used in set theory (called \\\"set comprehension\\\"). A simple example of a list comprehension is:</p> <pre><code>        [ n*n | n &lt;- [1..100] ]\n</code></pre> <p>This is a list containing (in order) the squares of all the numbers from 1 to 100. The above expression would be read aloud as \\\"list of all n<code>*</code>n such that n drawn from the list 1 to 100\\\". Note that \\\"n\\\" is a local variable of the above expression. The variable-binding construct to the right of the bar is called a \\\"generator\\\" - the \\\"\\&lt;-\\\" sign denotes that the variable introduced on its left ranges over all the elements of the list on its right. The general form of a list comprehension in Miranda is:</p> <pre><code>        [ body | qualifiers ]\n</code></pre> <p>Each qualifier is either a generator, of the form var\\&lt;-exp, or else a filter, which is a boolean expression used to restrict the ranges of the variables introduced by the generators. When two or more qualifiers are present they are separated by semicolons. An example of a list comprehension with two generators is given by the following definition of a function for returning a list of all the permutations of a given list,</p> <pre><code>        perms [] = [[]]\n        perms x = [ a:y | a &lt;- x; y &lt;- perms (x--[a]) ]\n</code></pre> <p>The use of a filter is shown by the following definition of a function which takes a number and returns a list of all its factors,</p> <pre><code>        factors n = [ i | i &lt;- [1..n div 2]; n mod i = 0 ]\n</code></pre> <p>List comprehensions often allow remarkable conciseness of expression. We give two examples. Here is a Miranda statement of Hoare\\'s \\\"Quicksort\\\" algorithm, as a method of sorting a list,</p> <pre><code>        sort [] = []\n        sort (a:x) = sort [ b | b &lt;- x; b&lt;=a ]\n                     ++ [a] ++\n                     sort [ b | b &lt;- x; b&gt;a ]\n</code></pre> <p>Next is a Miranda solution to the eight queens problem. We have to place eight queens on chess board so that no queen gives check to any other. Since any solution must have exactly one queen in each column, a suitable representation for a board is a list of integers giving the row number of the queen in each successive column. In the following script the function \\\"queens n\\\" returns all safe ways to place queens on the first n columns. A list of all solutions to the eight queens problem is therefore obtained by printing the value of (queens 8)</p> <pre><code>        queens 0 = [[]]\n        queens (n+1) = [ q:b | b &lt;- queens n; q &lt;- [0..7]; safe q b ]\n        safe q b = and [ ~checks q b i | i &lt;- [0..#b-1] ]\n        checks q b i = q=b!i \\/ abs(q - b!i)=i+1\n</code></pre> <p>[]{#Lazy}</p>"},{"location":"#lazy-evaluation-and-infinite-lists","title":"Lazy evaluation and infinite lists","text":"<p>Miranda\\'s evaluation mechanism is \\\"lazy\\\", in the sense that no subexpression is evaluated until its value is known to be required. One consequence of this is that is possible to define functions which are non-strict (meaning that they are capable of returning an answer even if one of their arguments is undefined). For example we can define a conditional function as follows,</p> <pre><code>        cond True x y = x\n        cond False x y = y\n</code></pre> <p>and then use it in such situations as \\\"cond (x=0) 0 (1/x)\\\".</p> <p>The other main consequence of lazy evaluation is that it makes it possible to write down definitions of infinite data structures. Here are some examples of Miranda definitions of infinite lists (note that there is a modified form of the \\\"..\\\" notation for endless arithmetic progressions)</p> <pre><code>        ones = 1 : ones\n        repeat a = x\n                   where x = a : x\n        nats = [0..]\n        odds = [1,3..]\n        squares = [ n*n | n &lt;- [0..] ]\n        perfects = [ n | n &lt;- [1..]; sum(factors n) = n ]\n        primes = sieve [ 2.. ]\n                 where\n                 sieve (p:x) = p : sieve [ n | n &lt;- x; n mod p &gt; 0 ]\n</code></pre> <p>One interesting application of infinite lists is to act as lookup tables for caching the values of a function. For example our earlier naive definition of \\\"fib\\\" can be improved from exponential to linear complexity by changing the recursion to use a lookup table, thus</p> <pre><code>        fib 0 = 1\n        fib 1 = 1\n        fib (n+2) = flist!(n+1) + flist!n\n                    where\n                    flist = map fib [ 0.. ]\n</code></pre> <p>Another important use of infinite lists is that they enable us to write functional programs representing networks of communicating processes. Consider for example the Hamming numbers problem - we have to print in ascending order all numbers of the form 2\u2191a\u00a0\u00d7\u00a03\u2191b\u00a0\u00d7\u00a05\u2191c, for a,b,c\u22650. There is a nice solution to this problem in terms of communicating processes, which can be expressed in Miranda as follows</p> <pre><code>        hamming = 1 : merge (f 2) (merge (f 3) (f 5))\n                  where\n                  f a = [ n*a | n &lt;- hamming ]\n                  merge (a:x) (b:y) = a : merge x (b:y), if a&lt;b\n                                    = b : merge (a:x) y, if a&gt;b\n                                    = a : merge x y,     otherwise\n</code></pre> <p>[]{#Poly}</p>"},{"location":"#polymorphic-strong-typing","title":"Polymorphic strong typing","text":"<p>Miranda is strongly typed. That is, every expression and every subexpression has a type, which can be deduced at compile time, and any inconsistency in the type structure of a script results in a compile time error message. We here briefly summarise Miranda\\'s notation for its types.</p> <p>There are three primitive types, called num, bool, and char. The type num comprises integer and floating point numbers (the distinction between integers and floating point numbers is handled at run time - this is not regarded as being a type distinction). There are two values of type bool, called True and False. The type char comprises the ascii character set - character constants are written in single quotes, using C escape conventions, e.g. \\'a\\', \\'\\$\\', \\'\\n\\' etc.</p> <p>If T is type, then [T] is the type of lists whose elements are of type T. For example [[1, 2], [2, 3], [4, 5]] is of type [[num]], that is list of lists of numbers. String constants are of type [char], in fact a string such as \\\"hello\\\" is simply a shorthand way of writing [\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\'].</p> <p>If T1 to Tn are types, then (T1, ... ,Tn) is the type of tuples with objects of these types as components. For example (True, \\\"hello\\\", 36) is of type (bool, [char], num).</p> <p>If T1 and T2 are types, then T1-&gt;T2 is the type of a function with arguments in T1 and results in T2. For example the function sum is of type [num]-&gt;num. The function quadsolve, given earlier, is of type num-&gt;num-&gt;num-&gt;[num]. Note that \\\"-&gt;\\\" is right associative.</p> <p>Miranda scripts can include type declarations. These are written using \\\"::\\\" to mean is of type. Example</p> <pre><code>        sq :: num -&gt; num\n        sq n = n * n\n</code></pre> <p>The type declaration is not necessary, however. The compiler is always able to deduce the type of an identifier from its defining equation. Miranda scripts often contain type declarations as these are useful for documentation (and they provide an extra check, since the typechecker will complain if the declared type is inconsistent with the inferred one).</p> <p>Types can be polymorphic, in the sense of Milner 1978. This is indicated by using the symbols *\u00a0\u00a0**\u00a0\u00a0***\u00a0\u00a0etc., as an alphabet of generic type variables. For example, the identity function, defined in the Miranda library as</p> <pre><code>        id x = x\n</code></pre> <p>has the following type</p> <pre><code>        id :: * -&gt; *\n</code></pre> <p>this means that the identity function has many types. Namely all those which can be obtained by substituting an arbitrary type for the generic type variable, eg \\\"num-&gt;num\\\", \\\"bool-&gt;bool\\\", \\\"(*-&gt;**) -&gt; (*-&gt;**)\\\" and so on.</p> <p>We illustrate the Miranda type system by giving types for some of the functions so far defined in this article</p> <pre><code>        fac :: num -&gt; num\n        ack :: num -&gt; num -&gt; num\n        sum :: [num] -&gt; num\n        month :: [char] -&gt; bool\n        reverse :: [*] -&gt; [*]\n        fst :: (*,**) -&gt; *\n        snd :: (*,**) -&gt; **\n        foldr :: (*-&gt;**-&gt;**) -&gt; [*] -&gt; **\n        perms :: [*] -&gt; [[*]]\n</code></pre> <p>[]{#User}</p>"},{"location":"#user-defined-types","title":"User defined types","text":"<p>The user may introduce new types. This is done by an equation in \\\"::=\\\". For example a type of labelled binary trees (with numeric labels) would be introduced as follows,</p> <pre><code>        tree ::= Nilt | Node num tree tree\n</code></pre> <p>This introduces three new identifiers - \\\"tree\\\" which is the name of the type, and \\\"Nilt\\\" and \\\"Node\\\" which are the constructors for trees - note that constructors must begin with an upper case letter. Nilt is an atomic constructor, while Node takes three arguments, of the types shown. Here is an example of a tree built using these constructors</p> <pre><code>        t1 = Node 7 (Node 3 Nilt Nilt) (Node 4 Nilt Nilt)\n</code></pre> <p>To analyse an object of user defined type, we use pattern matching. For example here is a definition of a function for taking the mirror image of a tree</p> <pre><code>        mirror Nilt = Nilt\n        mirror (Node a x y) = Node a (mirror y) (mirror x)\n</code></pre> <p>User defined types can be polymorphic - this is shown by introducing one or more generic type variables as parameters of the \\\"::=\\\" equation. For example we can generalise the definition of tree to allow arbitrary labels, thus</p> <pre><code>        tree * ::= Nilt | Node * (tree *) (tree *)\n</code></pre> <p>introduces a family of tree types, including tree\u00a0num, tree\u00a0bool, tree\u00a0(char-&gt;char), and so on.</p> <p>The types introduced by \\\"::=\\\" definitions are called \\\"algebraic types\\\". Algebraic types are a very general idea. They include scalar enumeration types, eg</p> <pre><code>        color ::= Red | Orange | Yellow | Green | Blue | Indigo | Violet\n</code></pre> <p>and also give us a way to do union types, for example</p> <pre><code>        bool_or_num ::= Left bool | Right num\n</code></pre> <p>It is interesting to note that all the basic data types of Miranda could be defined from first principles, using \\\"::=\\\" equations. For example here are type definitions for bool, (natural) numbers and lists,</p> <pre><code>        bool ::= True | False\n        nat ::= Zero | Suc nat\n        list * ::= Nil | Cons * (list *)\n</code></pre> <p>Having types such as \\\"num\\\" built in is done for reasons of efficiency - it isn\\'t logically necessary.</p> <p>[Note]{.underline}: In versions of Miranda before release two (1989) it was possible to associate \\\"laws\\\" with the constructors of an algebraic type, which are applied whenever an object of the type is built. For details see Turner 1985, Thompson 1986. This feature was little used and has since been removed from the language. []{#Type}</p>"},{"location":"#type-synonyms","title":"Type synonyms","text":"<p>The Miranda programmer can introduce a new name for an already existing type. We use \\\"==\\\" for these definitions, to distinguish them from ordinary value definitions. Examples</p> <pre><code>        string == [char]\n        matrix == [[num]]\n</code></pre> <p>Type synonyms are entirely transparent to the typechecker - it is best to think of them as macros. It is also possible to introduce synonyms for families of types. This is done by using generic type symbols as formal parameters, as in</p> <pre><code>        array * == [[*]]\n</code></pre> <p>so now eg <code>array num\\' is the same type as</code>matrix`. []{#Abstract}</p>"},{"location":"#abstract-data-types","title":"Abstract data types","text":"<p>In addition to concrete types, introduced by \\\"::=\\\" or \\\"==\\\" equations, Miranda permits the definition of abstract types, whose implementation is \\\"hidden\\\" from the rest of the program. To show how this works we give the standard example of defining stack as an abstract data type (here based on lists):</p> <pre><code>        abstype stack *\n        with  empty :: stack *\n              isempty :: stack * -&gt; bool\n              push :: * -&gt; stack * -&gt; stack *\n              pop :: stack * -&gt; stack *\n              top :: stack * -&gt; *\n\n        stack * == [*]\n        empty = []\n        isempty x = (x=[])\n        push a x = (a:x)\n        pop (a:x) = x\n        top (a:x) = a\n</code></pre> <p>We see that the definition of an abstract data type consists of two parts. First a declaration of the form \\\"abstype ... with ...\\\", where the names following the \\\"with\\\" are called the [signature]{.underline} of the abstract data type. These names are the interface between the abstract data type and the rest of the program. Then a set of equations giving bindings for the names introduced in the abstype declaration. These are called the [implementation equations]{.underline}.</p> <p>The type abstraction is enforced by the typechecker. The mechanism works as follows. When typechecking the implementation equations the abstract type and its representation are treated as being the same type. In the whole of the rest of the script the abstract type and its representation are treated as two separate and completely unrelated types. This is somewhat different from the usual mechanism for implementing abstract data types, but has a number of advantages. It is discussed at somewhat greater length in [Turner 85]. []{#Separate}</p>"},{"location":"#separate-compilation-and-linking","title":"Separate compilation and linking","text":"<p>The basic mechanisms for separate compilation and linking are extremely simple. Any Miranda script can contain one or more directives of the form</p> <pre><code>        %include \"pathname\"\n</code></pre> <p>where \\\"pathname\\\" is the name of another Miranda script file (which might itself contain include directives, and so on recursively - cycles in the include structure are not permitted however). The visibility of names to an including script is controlled by a directive in the included script, of the form</p> <pre><code>        %export names\n</code></pre> <p>It is permitted to export types as well as values. It is not permitted to export a value to a place where its type is unknown, so if you export an object of a locally defined type, the typename must be exported also. Exporting the name of a \\\"::=\\\" type automatically exports all its constructors. If a script does not contain an export directive, then the default is that all the names (and typenames) it defines will be exported (but not those which it acquired by %include statements).</p> <p>It is also permitted to write a [parametrised]{.underline} script, in which certain names and/or typenames are declared as \\\"free\\\". An example is that we might wish to write a package for doing matrix algebra without knowing what the type of the matrix elements are going to be. A header for such a package could look like this:</p> <pre><code>        %free { element :: type\n                zero, unit :: element\n                mult, add, subtract, divide :: element-&gt;element-&gt;element\n              }\n\n        %export matmult determinant eigenvalues eigenvectors \u2026\n        || here would follow definitions of matmult, determinant,\n        || eigenvalues, etc.  in terms of the free identifiers zero,\n        || unit, mult, add, subtract, divide\n</code></pre> <p>In the using script, the corresponding %include statement must give a set of bindings for the free variables of the included script. For example here is an instantiation of the matrix package sketched above, with real numbers as the chosen element type:</p> <pre><code>        %include \"matrix_pack\"\n                 { element == num; zero = 0; unit = 1\n                   mult = *; add = +; subtract = -; divide = /\n                 }\n</code></pre> <p>The three directives %include, %export and %free provide the Miranda programmer with a flexible and type secure mechanism for structuring larger pieces of software from libraries of smaller components.</p> <p>Separate compilation is administered without user intervention. Each file containing a Miranda script is shadowed by an object code file created by the system and object code files are automatically recreated and relinked if they become out of date with respect to any relevant source. (This behavior is similar to that achieved by the UNIX program \\\"make\\\", except that here the user is not required to write a makefile - the necessary dependency information is inferred from the %include directives in the Miranda source.) []{#Current}</p>"},{"location":"#current-implementation-status","title":"Current implementation status","text":"<p>An implementation of Miranda is available for a range of UNIX machines including SUN-4/Sparc, DEC Alpha, MIPS, Apollo, Sequent Symmetry, Sequent Balance, Silicon Graphics, IBM RS/6000, HP9000, PC/Linux. This is an interpretive implementation which works by compiling Miranda scripts to an intermediate code based on combinators. It is currently running at 550 sites (as of August 1996).</p> <p>Licensing information can be obtained from the world-wide web at http://miranda.org.uk\\ \\</p>"},{"location":"#references","title":"REFERENCES","text":"<p>[]{#M78}</p> <p>Milner, R. \\\"A Theory of Type Polymorphism in Programming\\\" Journal of Computer and System Sciences, vol 17, 1978.</p> <p>[]{#TH86}</p> <p>Thompson, S.J. \\\"Laws in Miranda\\\" Proceedings 4th ACM International Conference on LISP and Functional Programming, Boston Mass, August 1986.</p> <p>[]{#T85}</p> <p>Turner, D.A. \\\"Miranda: A non-strict functional language with polymorphic types\\\" Proceedings IFIP International Conference on Functional Programming Languages and Computer Architecture, Nancy France, September 1985 (Springer Lecture Notes in Computer Science, vol 201).</p> <p>[Note - this overview of Miranda first appeared in SIGPLAN Notices, December 1986. It has here been revised slightly to bring it up to date.]</p>"},{"location":"10/","title":"Identifiers","text":"<p>An identifier consists of a letter followed by zero or  more  additional characters  which  may  be  letters  digits  or  occurrences  of  _ or ' (underscore and single quote) Examples:</p> <pre><code>    x  yellow  p11d  y'  GROSS_INCOME\n</code></pre> <p>Note that both upper and lower case letters are allowed,  and  they  are treated  as different, so x and X are not the same identifier.  There is no restriction on the length of identifiers, and all the characters  are significant   in   deciding   whether  two  identifiers  are  the  same. Identifiers fall into two different classes (called in the formal syntax <code>identifier' and</code>IDENTIFIER`) depending on whether their initial letter is upper or lower case.</p> <p>Identifiers are used for three different purposes in Miranda  -  (i)  as variables,  i.e.  names for values (note that the names of functions are also considered to be variables), (ii) as typenames, such as <code>bool</code>  and <code>char</code>, and (iii) as constructors (see section on algebraic types).  The names of constructors must  begin  with  an  upper  case  letter,  while variables and typenames must begin with a lower case letter.</p>"},{"location":"10/#reserved-words","title":"Reserved  words","text":"<p>The  following  are  special  symbols of the Miranda language.</p> <p><code>abstype div if mod otherwise readvals show type where with</code></p> <p>These are often shown as underlined (or bold)  in  published  documents, but in programs they are typed as ordinary lower case words (which means that these words cannot be used as identifiers).</p>"},{"location":"10/#predefined-identifiers","title":"Predefined identifiers","text":"<p>The following identifiers are normally predefined, and  thus  always  in scope.  They constitute the <code>standard environment</code>.  They are defined in the script \"stdenv.m\", contained in the directory /usr/lib/miralib.</p> <p>(a) predefined typenames     bool char num sys_message</p> <p>(b) predefined constructors     False True :: bool     Appendfile Closefile Exit Stderr Stdout System Tofile :: sys_message</p> <p>(c) predefined variables     abs and arctan cjustify code concat const converse cos decode  digit     drop dropwhile e entier error exp filemode filter foldl foldl1 foldr     foldr1 force fst getenv hd hugenum id  index  init  integer  iterate     last  lay  layn  letter  limit lines ljustify log log10 map map2 max     max2 member merge min min2 mkset neg numval or  pi  postfix  product     read   rep  repeat  reverse  rjustify  scan  seq  showfloat  shownum     showscaled sin  snd  sort  spaces  sqrt  subtract  sum  system  take     takewhile  tinynum tl transpose undef until zip2 zip3 zip4 zip5 zip6     zip (88)</p> <p>See manual entry <code>Standard environment</code> for more detailed information.</p> <p>[NB There ought to be a way of suppressing or modifying the inclusion of the  standard  environment,  in  case  you  want  to  use  one  of these identifiers for another purpose - a mechanism for  doing  this  will  be provided in later releases.]</p>"},{"location":"11/","title":"Literals","text":"<p>There  are  three  types  of  literal  constant  -  numerals,  character constants, and string constants.</p> <p>Numerals are written in the following style</p> <pre><code>    12  5237563  24.6  4.5e13  0.63e-6\n</code></pre> <p>A numeral containing either a decimal point or a scale  factor  (<code>.</code>  or <code>e</code>)  is  fractional,  and  is  stored  internally  as  double precision floating point (accuracy approximately 17 decimal digits).  Integers are held   in  a  different  internal  representation,  and  have  unbounded precision.</p> <p>The two kinds of number, integer and fractional, are both of type <code>num</code>, as  far  as  the  type-checker  is concerned, and can be freely mixed in calculations.  There is automatic conversion from integer to  fractional when  required,  but  not  in  the  opposite direction.  To convert from fractional to integer, use <code>entier</code> (see standard environment).</p> <p>Negative numbers are denoted by applying the prefix <code>-</code>  operator  to  a numeral, thus:</p> <pre><code>    -12  -4.5e13\n</code></pre> <p>but  note  that  the notation -12 is an expression, not a literal, so if you wish to apply a function to it, you must write f (-12), not  f  -12, which would be read as an attempt to subtract 12 from f.</p> <p>Character constants are written using single quotes, thus</p> <pre><code>    'a'    '0'    '\\n'\n</code></pre> <p>String constants are written using double quotes, thus</p> <pre><code>    \"hello dolly\"    \"\"    \"\\n\\n\\n\"\n</code></pre> <p>Escape  conventions  in  character  and  string constants are as in <code>C</code>, using the backslash character.</p> <pre><code>    \\n    newline\n    \\t    tab\n    \\f    formfeed\n    \\r    carriage return\n    \\b    backspace\n    \\\\    the backslash character itself\n    \\'    single quote\n    \\\"    double quote\n    \\ddd  up to three decimal digits, arbitrary ascii character code\n</code></pre> <p>Note that literal newlines are not allowed inside  character  or  string quotes,  unless  escaped  by  backslash,  in  which  case the newline is ignored.  Thus</p> <pre><code>    \"hello \\\n</code></pre> <p>dolly\" means the same as \"hello dolly\".</p> <p>These conventions are exactly as in <code>C</code>,  except  that  we  use  decimal rather  than  octal  for  numeric  specification  of  an arbitrary ascii character code (the use of  octal  numbers  in  computing  now  seems  a curious anachronism which there is no need to perpetuate).</p>"},{"location":"12/","title":"Tokenisation and layout","text":"<p>A Miranda script or expression is regarded as being composed of  tokens, separated by layout.</p> <p>A token is one of the following -  an  identifier,  a  literal,  a  type variable,  or a delimiter.  Identifiers and literals each have their own manual section.  A type variable is a sequence of  one  or  more  stars, thus  *   *  etc.   (see basic type structure).  Delimiters are the miscellaneous symbols, such as operators, parentheses, and keywords.   A formal  definition  of the syntax of tokens, including a list of all the delimiters in given under <code>Miranda lexical syntax</code>.</p>"},{"location":"12/#rules-about-layout","title":"RULES ABOUT LAYOUT","text":"<p>Layout consists of white space characters (spaces,  tabs,  newlines  and formfeeds),  and  comments.   A  comment  consists of a pair of adjacent vertical bars, together with all the text to the right of  the  bars  on the same line.  Thus</p> <pre><code>    || this is a comment\n</code></pre> <p>Layout  is  not  permitted  inside  tokens  (except  in  char and string constants, where it is significant) but may be inserted  freely  between tokens to make scripts more readable.  Layout is ignored by the compiler except in two respects:</p> <p>1) At least one space (or  other  layout  characters)  must  be  present between  two  tokens  that  would otherwise form an instance of a single larger token.  For example in</p> <pre><code>    f 19 'b'\n</code></pre> <p>we have a function, f, applied to a number and a character,  but  if  we were to omit the two intervening spaces, the compiler would read this as a single six-character identifier, because both digits and single-quotes are  legal  characters  in  an identifier.  (Where it is not required to force the correct tokenisation, or because  of  the  offside  rule,  see below, the presence of layout between tokens is optional.)</p> <p>2)  Certain  syntactic  objects  (roughly,  the  right  hand  sides   of declarations  --  for  an exact account see those entities followed by a <code>(;)' in the formal syntax) obey Landin</code>s offside  rule  [Landin  1966]. This  requires  that every token of the object lie either directly below or to the right of its first token.  A token which breaks this  rule  is said  to  be  <code>offside</code>  with  respect to that object and terminates its parse.  For example in</p> <pre><code>    x = 2 &lt; a\n    y = f q\n</code></pre> <p>the 'y' is offside with respect to the right hand side of the definition of  'x'  (because it is to the left of the initial '2').  In such a case the trailing semicolon may be omitted from the right hand  side  of  the equation for x.</p> <p>It  is  because of the offside rule that Miranda scripts do not normally contain explicit semicolons as terminators for  definitions.   The  same rule  enables  the compiler to determine the scopes of nested where's by looking at their indentation levels.  For example in</p> <pre><code>    f x = g y z\n            where\n            y = (x+1)*(x-1)\n            z = p x (q y)\n    g r = groo (r+1)\n</code></pre> <p>it is the offside rule which makes it clear that the definition  of  'g' is  not local to the right hand side of the definition of 'f', but those of 'y' and 'z' are.</p> <p>It is always possible to terminate a right  hand  side  by  an  EXPLICIT semicolon,  instead  of  relying  on  the offside rule.  For example the above script could be written all in one line, as</p> <pre><code>    f x = g y z where y = (x+1)*(x-1); z = p x (q y);; g r = groo (r+1);\n</code></pre> <p>Notice that we need TWO semicolons after the definition of z - the first terminates  the  rhs of the definition of <code>z</code>, and the second terminates the larger rhs of which it is a part, namely that of the  definition  of <code>f'.   If we put only one semicolon at this point, the definition of</code>g<code>would be local to that of</code>f`.</p> <p>This  example  should  convince  the  reader  that  code  using   layout information  to show the block structure is much more readable, and this is the normal practise.</p> <p>[Reference P.J. Landin \"The Next 700 Programming Languages\", CACM vol  9 pp157-165 (March 1966).]</p> <p>Note that an additional comment  convention  applies  in  scripts  whose first  character  is  a  <code>&gt;</code>.   See  separate  manual entry on `literate scripts'.</p>"},{"location":"13-1/","title":"Dotdot notation","text":"<p>The following abbreviations are provided for  denoting  lists,  of  type [num],  whose  members form a finite or infinite arithmetic series.  Let <code>a',</code>b', <code>c</code> stand for arbitrary numeric expressions.</p> <pre><code>    [a..b]     list of numbers from a to b inclusive, interval = 1\n    [a..]      infinite list starting at a and increasing by 1\n    [a,b..c]   arithmetic series, first member a, second member b,\n            last member not greater than c (if b-a non-negative)\n            or not less than c (if b-a negative).\n    [a,b..]    infinite series starting at a, interval = (b-a)\n</code></pre> <p>So the notation [1..10] has as value  the  list  [1,2,3,4,5,6,7,8,9,10]. Here are some more examples</p> <pre><code>    nats = [0..]\n    evens = [0,2..]\n    odds_less_than_100 = [1,3..99]\n    neg_odds = [-1,-3..]\n    tenths = [1.0,1.1 .. 2.0]\n</code></pre>"},{"location":"13-2/","title":"List comprehensions","text":"<pre><code>    [exp | qualifiers]\n</code></pre> <p>List of all <code>exp' such that</code>qualifiers`.  If  there  are  two  or  more qualifiers they are separated by semicolons.  Each qualifier is either a generator, of which the allowed forms are</p> <pre><code>    pattern-list &lt;-  exp            (first form)\n\n    pattern &lt;- exp, exp ..          (second form)\n</code></pre> <p>or else a filter, which is a boolean expression restricting the range of the   variables  introduced  by  preceding  generators.   The  variables introduced on the left of each <code>&lt;-</code> are local to the list comprehension.</p> <p>Some examples</p> <pre><code>    sqs = [ n*n | n&lt;-[1..] ]\n\n    factors n = [ r | r&lt;-[1..n div 2]; n mod r = 0 ]\n\n    knights_moves [i,j] = [ [i+a,j+b] | a,b&lt;-[-2..2]; a^2+b^2=5 ]\n</code></pre> <p>Notice that a list of variables on the lhs of a <code>&lt;-</code>  is  shorthand  for multiple generators, e.g. <code>i,j&lt;-thing' expands to</code>i&lt;-thing; j&lt;-thing`.</p> <p>The variables introduced by the generators come into scope from left  to right,  so  later  generators  can  make  use of variables introduced by earlier ones.  An example of this is shown by the  following  definition of a function for generating all the permutations of a given list.</p> <pre><code>    perms [] = [[]]\n    perms  x = [ a:p | a&lt;-x; p&lt;-perms(x--[a]) ]\n</code></pre> <p>The  second  form  of  generator  allows  the construction of lists from arbitrary recurrence relations, thus         x &lt;- a, f x .. causes x to assume in turn the values <code>a',</code>f a',  <code>f(f  a)</code>,  etc.</p> <p>An example of its use is in the following definition  of  the  fibonacci series</p> <pre><code>    fibs = [ a | (a,b) &lt;- (1,1), (b,a+b) .. ]\n</code></pre> <p>Another  example  is  given  by the following expression which lists the powers of two</p> <pre><code>    [ n | n &lt;- 1, 2*n .. ]\n</code></pre> <p>The  order  of  enumeration  of  a  list  comprehension  with   multiple generators  is  like  that  of  nested  for-loops,  with  the  rightmost generator  as  the  innermost  loop.   For  example  the  value  of  the comprehension [ f x y | x&lt;-[1..4]; y&lt;-[1..4] ] is</p> <pre><code>    [ f 1 1, f 1 2, f 1 3, f 1 4, f 2 1, f 2 2, f 2 3, f 2 4,\n    f 3 1, f 3 2, f 3 3, f 3 4, f 4 1, f 4 2, f 4 3, f 4 4 ]\n</code></pre> <p>As a consequence of this order of enumeration of multiple generators, if any  generator  other  than  the  first  (leftmost)  is  infinite,  some combinations of values will never be reached  in  the  enumeration.   To overcome  this  a  second,  diagonalising, form of list comprehension is provided (see separate manual section).</p> <p>Note that list comprehensions do NOT remove duplicates from  the  result list.   To  remove  duplicates  from a list, apply the standard function <code>mkset</code>.</p>"},{"location":"13-3/","title":"Diagonalising list comprehensions","text":"<pre><code>    [ exp // qualifiers ]\n</code></pre> <p>Syntax and scope rules exactly as for standard list comprehensions,  the only difference being the use of <code>//</code> in place of the vertical bar.  The order of enumeration of the generators is such  that  it  is  guaranteed that  every  possible  combination of values will be reached eventually. The diagonalisation algorithm used is \"fair\" in the sense that it  gives equal priority to all of the generators.</p> <p>For example the value of <code>[f x y//x&lt;-[1..4]; y&lt;-[1..4]]</code> is</p> <pre><code>    [ f 1 1, f 1 2, f 2 1, f 1 3, f 2 2, f 3 1, f 1 4, f 2 3,\n    f 3 2, f 4 1, f 2 4, f 3 3, f 4 2, f 3 4, f 4 3, f 4 4 ]\n</code></pre> <p>The algorithm used used is \"Cantorian  diagonalisation\"  -  imagine  the possible  combinations  of  values from the two generators laid out in a (perhaps infinite) rectangular array, and traverse each diagonal in turn starting  from  the origin.  The appropriate higher-dimensional analogue of this algorithm is used for the case  of  a  list  comprehension  with three or more generators.</p> <p>As an example of an enumeration that could not be defined at all using a standard list comprehension, because of the presence of several infinite generators, here  is  a  definition  of  the  list  of  all  pythagorean triangles (right-angled triangles with integer sides)</p> <pre><code>    pyths = [(a,b,c)//a,b,c&lt;-[1..];a^2+b^2=c^2]\n</code></pre> <p>In the case that there is only one generator, the use of <code>//</code> instead of <code>|</code> makes no difference to the meaning of the list comprehension.</p>"},{"location":"14/","title":"Scripts","text":"<p>In Miranda the script is  the  persistent  entity  that  is  saved  from session  to session (i.e.  it plays the role of what is called a program in conventional languages).  Associated with a Miranda  session  at  any given  time  is  a  single current script, identified by a UNIX pathname ending in <code>.m</code>.</p> <p>A script is a collection of declarations, establishing an environment in which  you  wish to evaluate expressions.  The order of the declarations in a script is not significant - for example  there  is  no  requirement that an identifier be defined before it is used.</p> <p>An identifier may not have more than one top-level binding  in  a  given script.</p> <p>Here are the kinds of declaration that can occur in a script:</p> <p>1)  a  definition (of a function, data structure etc. - see manual entry <code>definitions</code> for more details).  Example         fac n = product[1..n]</p> <p>2) a specification of the type of one or more identifiers, of the form         var-list ::  <p>Example</p> <pre><code>    fac :: num-&gt;num\n</code></pre> <p>See 'Basic type structure' for an account of possible types.  Note  that these  type  specifications are normally optional, since the compiler is able  to  deduce  them  from  the  definitions  of   the   corresponding identifiers.  It is however possible to introduce an identifier by means of a type specification only, without  giving  it  a  defining  equation (such  identifiers  are  said  to be <code>specified but not defined</code> and are useful  in  program  development).   A  special  case  of  this  is  the introduction  of  an  otherwise undefined typename - see separate manual entry on <code>placeholder types</code>.</p> <p>3) the definition of a user defined type - these  are  of  three  kinds, synonyms, algebraic types, and abstract types (see separate manual entry on each).</p> <p>4) a library directive (%export,  %include  or  %free)  these  are  used specify  the  interfaces  between  separately  compiled  scripts  -  see separate manual entry on the library mechanism.</p> <p>There is a manual entry giving the formal syntax of Miranda scripts.</p> <p>Note</p> <p>A directory called <code>ex' (meaning</code>examples<code>) containing a collection of example  scripts  is supplied with the Miranda system, and will be found under the</code>miralib<code>directory (usually kept at  /usr/lib/miralib  -  the Miranda  session  command</code>/miralib`  will tell you where it is on your system).</p> <p>A convention  which  the  Miranda  system  consistently  understands  in Miranda  session  commands,  library  directives etc. is that a pathname enclosed in , instead of \"string_quotes\" is relative  to the  miralib  directory.   In  particular  note that the Miranda session command <pre><code>    /cd &lt;ex&gt;\n</code></pre> <p>will change your current directory to  be  \"..../miralib/ex\".   You  can then say, e.g.</p> <pre><code>    !ls\n</code></pre> <p>to see what's in there.  In fact there is a README file, so a good thing to say next would be</p> <pre><code>    !vi README\n</code></pre>"},{"location":"15/","title":"Definitions","text":"<p>The purpose of a definition is to give a value to one or more variables. There  are  two kinds of definition, <code>scalar' and</code>conformal`.  A scalar definition gives a value to a single variable, and consists  of  one  or more consecutive equations of the form</p> <pre><code>    fnform = rhs\n</code></pre> <p>where  a <code>fnform</code> consists of the name being defined followed by zero or more formal parameters.  Here are three examples of scalar  definitions, of <code>answer',</code>sqdiff' and <code>equal</code> respectively</p> <pre><code>    answer = 42\n\n    sqdiff a b = a^2 - b^2\n\n    equal a a = True\n    equal a b = False\n</code></pre> <p>When a scalar definition consists of more than one equation,  the  order of the equations can be significant, as the last example shows.  (Notice that <code>equals</code> as defined here is a function of two  arguments  with  the same action as the built in <code>=</code> operator of boolean expressions.)</p> <p>A conformal definition gives values to several variables  simultaneously and is an equation of the form</p> <pre><code>    pattern = rhs\n</code></pre> <p>An example of this kind of definition is</p> <pre><code>    (x,y,z) = ploggle\n</code></pre> <p>For this to make sense, the value of  <code>ploggle</code>  must  of  course  be  a 3-tuple.    More  information  about  the  pattern  matching  aspect  of definitions is given in the manual section of that name.</p> <p>Both fnform and pattern equations share a common notion of  `right  hand side'</p> <p>Right hand sides</p> <p>The simplest form of rhs is just an expression (as in all the  equations above).   It  is  also possible to give several alternative expressions, distinguished by guards.  A guard consists of the word <code>if</code> followed  by a  boolean  expression.   An  example  of a right hand side with several alternatives is given by the following definition of the greatest common divisor function, using Euclid's algorithm</p> <pre><code>    gcd a b = gcd (a-b) b,  if a&gt;b\n            = gcd a (b-a),  if a&lt;b\n            = a,            if a=b\n</code></pre> <p>Note that the guards are written on the right, following a  comma.   The layout  is  significant (because the offside rule is used to resolve any ambiguities in the parse).</p> <p>The last guard can be written <code>otherwise</code>, to indicate that this is  the case  which  applies if all the other guards are false.  For example the correct rule for recognising a leap year can be written:</p> <pre><code>    leap y = y div 400 = 0,    if y mod 100 = 0\n            = y div 4 = 0,      otherwise\n</code></pre> <p>The otherwise may here be regarded as standing for if y mod  100  ~=  0. In  the  general  case it abbreviates the conjunction of the negation of all the previous guards, and may be used to avoid  writing  out  a  long boolean expression.</p> <p>Although it is better style to write guards that are mutually exclusive, this is not something the compiler can enforce - in the general case the alternative selected is the first (in the order they are written)  whose guard evaluates to True.</p> <p>[In older versions of Miranda the presence of the keyword <code>if</code> after the guard comma was optional.]</p> <p>Block structure</p> <p>A right hand side can be qualified by a where clause.  This  is  written after the last alternative.  The bindings introduced by the where govern the whole rhs, including the guards.  Example</p> <pre><code>    foo x = p + q, if p&lt;q\n            = p - q, if p&gt;=q\n            where\n            p = x^2 + 1\n            q = 3*x^3 - 5\n</code></pre> <p>Notice that the whole where clause must be indented, to show that it  is part  of  the  rhs.  Following a where can be any number of definitions, and the syntax of such local definitions is exactly the same as that for top level definitions (including therefore, recursively, the possibility that they may contain nested where's).</p> <p>It is not  permitted  to  have  locally  defined  types,  however.   New typenames can be introduced only at top level.</p>"},{"location":"16/","title":"Pattern Matching","text":"<p>The notion of <code>pattern</code> plays an important role in Miranda.   There  are three  contexts in which patterns can be used - in function definitions, in  conformal  definitions,  and  on  the  left  of  the  <code>&lt;-</code>  in  list comprehensions.    We  first  explain  the  general  rules  for  pattern formation, which are the same in all three contexts.</p> <p>Patterns are built from variables  and  constants,  using  constructors. Here are some simple examples.</p> <pre><code>    x\n    3\n    (x,y,3)\n</code></pre> <p>The  first pattern is just the variable x, the second is the constant 3, the last example is built from two variables and a constant,  using  the (,,)  constructor  for 3-tuples.  The components of a structured pattern can themselves be arbitrary patterns, permitting  nested  structures  of any depth.</p> <p>A  pattern  can  also  contain  repeated  variables, e.g.  <code>(x,1,x)</code>.  A pattern containing repeated variables matches  a  value  only  when  the parts of the value corresponding to occurrences of the same variable are equal.</p> <p>The constructors which can be used in a pattern include those  of  tuple formation  <code>(..,..)',  list formation</code>[..,..]`, and the constructors of any user defined Algebraic  Type  (see  separate  manual  section).   In addition  there are special facilities for matching on lists and natural numbers, as follows.</p> <p>(Lists) The <code>:</code> operator can be used in patterns,  so  for  example  the following three patterns are all equivalent (and will match any 2-list).</p> <pre><code>    a:b:[]\n    a:[b]\n    [a,b]\n</code></pre> <p>Note that <code>:</code> is right associative (see manual section on Operators).</p> <p>(Natural numbers) It is permitted to write patterns of  the  form  <code>p+k</code> where  p  is  a  pattern  and  k  is  a  literal integer constant.  This construction will succeed in matching a value n, if and only if n is  an integer  &gt;=k,  and  in  this  case  p is bound to (n-k).  Example, <code>y+1</code> matches  any   positive   integer,   and   <code>y</code>   gets   bound   to   the integer-minus-one.</p> <p>Note that the automatic coercion from integer to floating  point,  which takes  place  in  expression  evaluation,  does  not  occur  in  pattern matching.  An integer pattern such as <code>3' or</code>n+1` will  not  match  any floating point number.  It is not permitted to write patterns containing floating point constants.</p> <p>Case analysis</p> <p>The main use of pattern matching in Miranda is in the left hand side  of function  definitions.  In the simplest case a pattern is used simply to provide the right hand side of the function definition  with  names  for subcomponents of a data structure.  For example, functions for accessing the elements of a 2-tuple may be defined,</p> <pre><code>    fst_of_two (a,b) = a\n    snd_of_two (a,b) = b\n</code></pre> <p>More generally  a  function  can  be  defined  by  giving  a  series  of equations,  in which the use of different patterns on the left expresses case analysis on the argument(s).  Some simple examples</p> <pre><code>    factorial 0 = 1\n    factorial(n+1) = (n+1)*factorial n\n\n    reverse [] = []\n    reverse (a:x) = reverse x ++ [a]\n\n    last [a] = a\n    last (a:x) = last x, if x~=[]\n    last [] = error \"last of empty list\"\n</code></pre> <p>Many more examples can be  found  in  the  definition  of  the  standard environment  (see  separate manual section).  Note that pattern matching can be combined with  the  use  of  guards  (see  last  example  above). Patterns  in  a  case  analysis  do  not  have  to be mutually exclusive (although as a matter of programming style that is good practice) -  the rule  is that cases are tried in order from top to bottom, and the first equation which <code>matches</code> is used.</p> <p>Conformal definitions</p> <p>Apart from the simple case where the pattern is a single  variable,  the construction</p> <pre><code>    pattern = rhs\n</code></pre> <p>is called a <code>conformal definition</code>.  If the value of the right hand hand side matches the structure of the given pattern, the  variables  on  the left are bound to the corresponding components of the value.  Example</p> <pre><code>    [a,b,3] = [1,2,3]\n</code></pre> <p>defines  a  and b to have the values 1 and 2 respectively.  If the match fails anywhere, all the  variables  on  the  left  are  undefined.   For example, within the scope of the definition</p> <pre><code>    (x,x) = (1,2)\n</code></pre> <p>the  value of x is neither 1 nor 2, but undefined (i.e. an error message will result if you try to access the value of x in any way).</p> <p>As a constraint to prevent \"nonsense\" definitions, it is a rule that the pattern  on the left hand side of a conformal definition must contain at least one variable.  So e.g. <code>1  =  2</code>  is  not  a  syntactically  valid definition.</p> <p>Patterns on the left of generators</p> <p>In a list comprehension (see separate manual entry) the bound entity  on the  left  hand  side of an <code>&lt;-</code> symbol can be any pattern.  We give two simple examples - in both examples we assume x is a list of 2-tuples.</p> <p>To  denote  a  similar  list but with the elements of each tuple swapped over we can write</p> <pre><code>    [(b,a)|(a,b)&lt;-x]\n</code></pre> <p>To extract from x all second elements of a 2-tuple whose first member is 17, we can write</p> <pre><code>    [ b |(17,b)&lt;-x]\n</code></pre> <p>Irrefutable patterns (*) (Technical note, for people interested in denotational semantics)</p> <p>DEFINITION:- an algebraic type having only one constructor and for which that  constructor is non-nullary (ie has at least one field) is called a product type.  The constructor of a product type is  called  a  `product constructor'.</p> <p>Each type of n-tuple (n~=0) is also defined to be a  product  type.   In fact it should be clear that any user defined product type is isomorphic to a tuple type.  Example,  if we define</p> <pre><code>    wibney ::= WIB num bool\n</code></pre> <p>then the type wibney is isomorphic to the tuple type (num,bool).</p> <p>A pattern composed only of  product-constructors  and  identifiers,  and containing  no  repeated  identifiers, is said to be \"irrefutable\".  For example <code>WIB p q',</code>(x,y,z)' and <code>(a,(b,c))</code> are  irrefutable  patterns. We show what this means by an example.  Suppose we define f, by</p> <pre><code>    f :: (num,num,bool) -&gt; [char]\n    f (x,y,z) = \"bingo\"\n</code></pre> <p>As a result of the constraints of strong typing, f can only  be  applied to objects of type (num,num,bool) and given any actual parameter of that type, the above equation for f MUST match.</p> <p>Interestingly, this works even if the actual parameter is an  expression which does not terminate, or contains an error.  (For example try typing</p> <pre><code>    f undef\n</code></pre> <p>and you will get \"bingo\", not an error message.)</p> <p>This is because of  a  decision  about  the  denotational  semantics  of algebraic  types  in  Miranda  -  namely  that product types (as defined above) correspond to the domain construction DIRECT PRODUCT (as  opposed to  lifted  product).  This means that the bottom element of a type such as (num,num,bool) behaves indistinguishably from (bottom,bottom,bottom).</p> <p>Note that singleton types such as the empty tuple type <code>()</code>, or say,</p> <pre><code>    it ::= IT\n</code></pre> <p>are not product types under the above definition, and therefore patterns containing  sui-generis  constants such as () or IT are not irrefutable. This corresponds to a semantic decision that we do NOT wish to  identify objects such as () or IT with the bottom element of their type.</p> <p>For a more detailed discussion of  the  semantics  of  Miranda  see  the formal language definition (in preparation).</p> <p>(*) A useful discussion of the semantics of pattern-matching,  including the  issue  of  irrefutable patterns, can be found in (chapter 4 of) the following S.  L.  Peyton-Jones ``The Implementation of Functional Programming Languages'', Prentice Hall International, March 1987. ISBN 0-13-453333-X</p>"},{"location":"17/","title":"Compiler directives","text":"<p>Certain keywords, beginning with <code>%</code>, modify the action of the  compiler when  present in a script.  These are called <code>compiler directives</code>.  The directives currently available are as follows.</p> <p><code>%list %nolist</code></p> <pre><code>If the `/list` feature is  enabled  (switched  on  and  off  by  /list,\n</code></pre> <p>/nolist  at  command  level) the compiler echos the source to the user's terminal during compilation of a Miranda script.  The directives  %list, %nolist  may be placed in a file to give more detailed control over this behaviour.  If the compiler is in an  echoing  state  then  encountering <code>%nolist</code>  causes  it  to  cease  echoing from that point onwards in the source, until the next occurrence of '%list' or the end  of  the  source file  in  which  the  directive  occurs, whichever is the sooner.  These directives may occur anywhere in a script and  have  no  effect  on  the semantics  (i.e.   they  are  just  like  comments,  apart from having a side-effect on the lex analyser).</p> <p>If  the  <code>/list</code> feature of the compiler is not enabled these directives are ignored.  Since the default state of the compiler is  now  <code>/nolist</code> these  directives are of marginal value and retained only for historical reasons.</p> <pre><code>%insert\n    A directive of the form\n        %insert \"pathname\"\n</code></pre> <p>may occur anywhere in a Miranda script, and is textually replaced by the contents  of  the file \"pathname\" during lexical analysis.  The pathname must be given as a literal string, enclosed  in  double  quotes.   (Most uses of this directive are now better handled by %include, see below).</p> <p>If the %insert directive is textually indented in the file in  which  it occurs, the whole of the inserted text will be treated as being indented by the same amount as the initial <code>%</code> of the directive.</p> <p>Insert  directives  may be invoked recursively, to a depth limit imposed by the operating system, typically about 16, which should be enough  for any   reasonable   purpose.    Note  that  the  pathnames  are  resolved statically, not dynamically, so that the meaning of an %insert directive is computed relative to the file in which it occurs, NOT relative to the directory from which the compiler was invoked.</p> <p>The use of static rather than dynamic pathname resolution is a departure from  normal  UNIX conventions (both the <code>C</code> compiler and the UNIX shell resolve pathnames dynamically) but is much more convenient in practice.</p> <p>Note that if the subject of an %insert directive is a  complete  Miranda script  it  is  always better to use %include (see manual section on the library mechanism), since this  avoids  needless  recompilation  of  the definitions  of the subsidiary script.  The use of %include also imposes a hierarchical scope discipline, and is more  likely  to  lead  to  well structured code.</p> <p>A point to beware of when using %insert is that unlike %include, it does NOT add a missing <code>.m</code> extension to its pathname argument automatically. This is because the argument file may contain an arbitrary piece of text (e.g.   an expression or a signature) and need not be a complete Miranda script, so it would be inappropriate to insist that it is  pathname  end in <code>.m</code> in all cases.</p> <p>%include %export %free</p> <p>These directives control the  identifier  bindings  between  separately compiled  scripts.  See separate manual entry on <code>the library mechanism</code> for details.</p>"},{"location":"18/","title":"Basic type structure and notation for types","text":"<p>The Miranda programming language  is  strongly  typed  -  that  is  each expression  and each variable has a type that can be deduced by a static analysis of the program text.</p> <p>Primitive types num bool char</p> <p>Values of type <code>num</code> include both integer and  floating  point  numbers, e.g.</p> <pre><code>    23     0   -17   1.26e11\n</code></pre> <p>They  are  stored  using  different internal representations, but can be freely mixed in calculations, and  are  both  of  type  <code>num</code>  for  type checking  purposes.   There  is  automatic  conversion  from  integer to floating point when required (but not in the opposite  direction  -  use <code>entier</code>, see standard environment).  Floating point numbers are held to double precision, integers to unbounded precision.</p> <p>The values of type <code>bool</code> are the two truth values:</p> <pre><code>    True    False\n</code></pre> <p>The values of type <code>char</code> are ascii characters, e.g.</p> <pre><code>    'a'    '%'    '\\t'\n</code></pre> <p>List types</p> <p>[t] is the type of lists whose elements are of type <code>t</code></p> <p>Thus [num] is the type of lists of numbers such as [1,2,3,4,5]</p> <p>[[num]] is the type of lists of lists of numbers, such as [[1,2],[3,4]]</p> <p>[char] are lists of characters  -  this  is  also  the  type  of  string constants, so e.g. ['h','e','l','l','o'] and \"hello\" are interchangeable objects of this type.</p> <p>Tuple types</p> <p>(t1,...,tn) is the type of a tuple with elements of type <code>t1' to</code>tn`</p> <p>Example - the value (1,True,\"red\") is of type (num,bool,[char])</p> <p>The type of the empty tuple, <code>()', is also  written</code>()`.</p> <p>Notice  that  tuples  are  distinguished from lists by being enclosed in parentheses, instead of square brackets.</p> <p>There is no concept of a 1-tuple, in Miranda, so the use of  parentheses to  enclose  subexpressions,  as  in say a*(b+c), does not conflict with their use for tuple formation.</p> <p>Function types t1-&gt;t2 is the type of a function with argument  type  <code>t1</code>  and  result type <code>t2</code></p> <p>The '-&gt;' is right associative, so e.g.  <code>num-&gt;num-&gt;num</code> is the type of a curried function of two numeric arguments.</p> <p>In addition to the built-in types described above,  user  defined  types may  be  introduced - these are of three kinds, synonym types, algebraic types and abstract types - see separate manual entry for each.</p> <p>Implicit typing In Miranda the types of identifiers do NOT normally need to be declared explicitly  - the compiler is able to infer the type of identifiers from their defining equations.  For example if you write</p> <pre><code>    plural x = x ++ \"s\"\n</code></pre> <p>the compiler will DEDUCE that <code>plural</code> is of type [char]-&gt;[char].  It is however permitted to include explicit type declarations in the script if desired, e.g.  you could write (anywhere in the same script)</p> <pre><code>    plural :: [char]-&gt;[char]\n</code></pre> <p>and the compiler will check  this  for  consistency  with  the  defining equation  (the symbol <code>::' means</code>is of type`).  More generally the type declared may be an instance (see below)  of  the  type  implied  by  the definition  -  in this case the effect of the declaration is to restrict the type of the identifier to be less general than  it  would  otherwise have been.</p> <p>Note  that  only  top-level  identifiers  may  be  the  subject  of type declarations, and that the type of an identifier may be declared at most once in a given script.</p> <p>Polymorphism</p> <p>The  final  feature  of  the type system is that it permits polymorphic types.  There is an alphabet of generic type variables, written</p> <pre><code>    *    **    ***    etc.\n</code></pre> <p>each of which stands for an arbitrary type.  We give a simple example  - the identity function, which may be defined</p> <pre><code>    id x = x\n</code></pre> <p>is attributed the type <code>*-&gt;*'.  This means that</code>id<code>has  many  types  -</code>num-&gt;num', <code>char-&gt;char',</code>[[bool]]-&gt;[[bool]]<code>and so on - each of these is an instance of its most general type,</code>-&gt;`.</p> <p>Another simple example  of  polymorphism  is  the  function  <code>map</code>  (see standard  environment)  which  applies  a function to every element of a list.  For example <code>map integer [1,1.5,2]</code>  is  [True,False,True].   The type of map is</p> <pre><code>    map :: (*-&gt;**) -&gt; [*] -&gt; [**]\n</code></pre> <p>The most polymorphic possible object is <code>undef</code>,  the  identifier  which stands  for  the  undefined,  or  error  value  (undef is defined in the standard environment).  Since every type has  an  undefined  value,  the correct type specification for undef is</p> <pre><code>    undef :: *\n</code></pre> <p>Many of the functions in the standard environment have polymorphic types - the text of the standard environment (see separate  manual  entry)  is therefore a useful source of examples.</p>"},{"location":"19/","title":"Type synonym declarations","text":"<p>These permit the user to introduce a new name for  an  already  existing type, e.g.</p> <pre><code>    string == [char]\n</code></pre> <p>type  synonyms  are  entirely transparent to the typechecker (it best to think of them as being just macros). For obvious reasons, recursive type synonyms are not permitted.</p> <p>It  is also possible to introduce a synonym for a type forming operator, by introducing generic type variable as parameters  of  the  definition, e.g.</p> <pre><code>    invt * ** == (*-&gt;**)-&gt;(**-&gt;*)\n</code></pre> <p>So  within  a script containing the above two <code>==</code> definitions, the type <code>invt num string</code> will be shorthand for</p> <pre><code>    (num-&gt;[char])-&gt;([char]-&gt;num)\n</code></pre>"},{"location":"2/","title":"About the name 'Miranda'","text":"<pre><code>About the name `Miranda`\n\nThe word `Miranda' is not an acronym.  It is a proper name (like `ADA`).\n\n\"Miranda (f).  From the Latin meaning `to be admired`.   This  name  was\nfirst used by Shakespeare for the heroine of `The Tempest`, a young girl\nblessed with many admirable qualities.  Like other unusual Shakespearean\nnames it has been used quite frequently in the 20th century.\"\n\n               - Collins Dictionary of First Names,\n                 William Collins and Son Ltd, London, 1967\n\n\"O wonder! How many goodly creatures are there here! O brave new world.\"\n\n               - `The Tempest` by William Shakespeare\n                 (from a speech by Miranda, Act 5, Scene 1)\n\nImportant Note.  When used as  the  name  of  a  functional  programming\nsystem,  `Miranda` is a trademark (tm) of Research Software Ltd.\n\nNote that only the first letter of Miranda is upper  case  -  it  should\nnever be written all in capitals.\n</code></pre>"},{"location":"20/","title":"Algebraic type definitions","text":"<p>The simplest method of introducing a new data type into a Miranda script is  by  means of an algebraic type definition.  This enables the user to introduce a new concrete  data  type  with  specified  constructors.   A simple example would be</p> <pre><code>    tree ::= Nilt | Node num tree tree\n</code></pre> <p>The  <code>::='  sign (pronounced</code>comprises<code>) is always used to introduce an algebraic data type.  This definition introduces three new identifiers -</code>tree', a typename - <code>Nilt</code> a nullary constructor of type tree (i.e.  an atomic tree) - and <code>Node</code>, a constructor of type  num-&gt;tree-&gt;tree-&gt;tree. Now  we  can  define  a particular tree, using the constructors Nilt and Node, for example</p> <pre><code>    t = Node 3 Nilt Nilt\n</code></pre> <p>It is not necessary to have names for the selector functions because the constructors  can  be  used in pattern matching.  For example a function for counting the number of nodes in a tree could be written</p> <pre><code>    size Nilt = 0\n    size (Node a x y) = 1 + size x + size y\n</code></pre> <p>Note that the names of constructors must begin with an upper case letter (and  conversely,  any identifier beginning with an upper case letter is assumed to be a constructor).</p> <p>An algebraic type can have any number (&gt;=1)  of  constructors  and  each constructor  can  have any number (&gt;=0) fields, of specified types.  The number of fields taken by  a  constructor  is  called  its  <code>arity</code>.   A constructor  of  arity zero is said to be atomic.  Algebraic types are a very general idea and include a number of special cases  that  in  other languages require separate constructions.</p> <p>One  interesting case that all of the constructors can be atomic, giving us what is called in PASCAL a <code>scalar enumeration type</code>.  Example</p> <pre><code>    day ::= Mon|Tue|Wed|Thu|Fri|Sat|Sun\n</code></pre> <p>The union of two types can also be represented as an algebraic data type - for example here is a union of num and bool.</p> <pre><code>    boolnum ::= Left bool | Right num\n</code></pre> <p>Notice  that  this  is  a <code>labelled union type</code> (the other kind of union type, in which the parts of the union are not distinguished  by  tagging information, is not permitted in Miranda).</p> <p>An  algebraic typename can take parameters, thus introducing a family of types.   This  is  done  be  using  generic  type  variables  as  formal parameters  of the <code>::=' definition.  To modify our definition of</code>tree<code>to allow trees with different types of labels at the nodes  (instead  of all</code>num` as above) we would write</p> <pre><code>    tree * ::= Nilt | Node * (tree *) (tree *)\n</code></pre> <p>Now  we  have  many  different  tree  types  -  <code>tree num',</code>tree bool<code>,</code>tree([char]-&gt;[char])', and so on.  The constructors <code>Node'  and</code>Nilt<code>are  both  polymorphic, with types</code>tree <code>and</code>-&gt;tree -&gt;tree -&gt;tree *' respectively.</p> <p>Notice that in Miranda objects of a recursive user defined type are  not restricted  to  being  finite.   For example we can define the following infinite tree of type <code>tree num</code></p> <pre><code>    bigtree = Node 1 bigtree bigtree\n</code></pre> <p>Obsolete Language Features Algebraic data types in Miranda originally (see Turner 1985)  supported two additional features, which have now been dropped from the definition of the language.  These are  laws  (equations  on  constructors  written using  <code>=&gt;')  and  strictness annotations on fields in</code>::=` definitions (written as ! following the field type).</p> <p>The release-two compiler continues to support these features, so  former users  of Miranda release one do not lose working programs at the change to release two.  However, they will eventually cease to be supported  by the  Miranda  compiler (sorry!).  An <code>obsolete feature</code> warning given at each compilation of a script using them.  A methodology for  translating out these features is given in the CHANGES section of this manual.</p> <p>Laws and strictness annotations  are  no  longer  part  of  the  Miranda language, and should not be taught to new users.</p> <p>Reference: D. A. Turner ``Miranda: A Non-Strict Functional Language with Polymorphic   Types'',   Proceedings   IFIP   Conference  on  Functional Programming  Languages  and  Computer   Architecture,   Nancy,   France, September 1985 (Springer Lecture Notes in Computer Science 201:1-16).</p> <p>this can be found at http://miranda.org.uk</p>"},{"location":"21/","title":"Abstract type definitions","text":"<p>These enable a new data type to be defined by data type abstraction from an existing type.  We give the classic example, that of defining <code>stack</code> as an abstract data type (here based on lists)</p> <pre><code>    abstype stack *\n    with empty::stack *\n            push::*-&gt;stack *-&gt;stack *\n            isempty::stack *-&gt;bool\n            top::stack *-&gt;*\n            pop::stack *-&gt;stack *\n\n    stack * == [*]\n    empty = []\n    push a x = a:x\n    isempty x = x=[]\n    top (a:x) = a\n    pop (a:x) = x\n</code></pre> <p>The information given after  <code>with</code>  is  called  the  signature  of  the abstract  type - the definitions of the identifiers in the signature are called the <code>implementation equations</code> (these are the six equations given above).   Outside  of  the implementation equations the information that stacks are implemented as lists is not available  -  []  and  empty  for example  are incomparable objects of two different and unrelated types ( [*] and stack * respectively).  Only inside the implementation equations are   the   abstract  objects  treated  as  being  equivalent  to  their representations.</p> <p>The implementation equations do not have to appear immediately after the corresponding  abstype  declaration  -  they  can  occur anywhere in the script.  For readability, however, it is strongly recommended  that  the implementation   equations   appear   immediately   after   the  abstype declaration.</p> <p>Note  that  in  Miranda  there  is  no  runtime  cost  associated   with administering  an  abstract data type.  The responsibility for enforcing the distinction between stacks and lists,  for  example,  is  discharged entirely   at   compile   time  (by  the  type  checker).   The  runtime representation of a stack does not require any extra bits to distinguish it  from  a  list.   As  a  result the Miranda programmer can freely use abstract data types to structure his programs without incurring any loss of efficiency by doing so.</p> <p>Notice that the mechanism used  to  introduce  abstract  data  types  in Miranda  does  not  depend  on  the  hiding  of identifiers, and in this respect differs from the traditional approach.  A fuller  discussion  of the Miranda abstype mechanism can be found in [*Turner 85].</p> <p>(*) D.  A.  Turner ``Miranda:  A  Non-Strict  Functional  Language  with Polymorphic   Types'',   Proceedings   IFIP   Conference  on  Functional Programming  Languages  and  Computer   Architecture,   Nancy,   France, September 1985 (Springer Lecture Notes in Computer Science, vol. 201, pp 1-16).</p> <p>The print representation of abstract objects (\"advanced feature\" - omit on first reading)</p> <p>Values  belonging  to an abstract type are not in general printable.  If the value of a command-level expression  is  of  such  a  type  it  will normally print simply as</p> <p> <p>This is because the special function show (which is actually a family of functions, see elsewhere) has no  general  method  for  converting  such objects to a printable form.  It is possible to extend the definition of show to include the ability to print members of an abstract type,  using some appropriate format.  The convention for doing this is to include in the definition of the abstract type a function with the  name  <code>showfoo</code> (where <code>foo</code> is the name of the abstract type involved).</p> <p>We illustrate how this is done taking <code>stack</code> as the  example.   Suppose we  decide we wish stacks to print - using a syntax such that the output could be read back in (e.g. by readvals - see elsewhere) to generate the same stack.</p> <p>empty is to print as \"empty\" push 1 empty is to print as \"(push 1 empty)\" and so on.</p> <p>Note that we decide to fully parenthesise the output for safety -  since we  do  not  know  the  larger  context in which our stack output may be embedded.</p> <p>Because  <code>stack</code>  is  a  polymorphic abstraction, showstack will need to take as a parameter the appropriate show function for the  element  type (which  is num in the above examples, but could have been any type).  We add to the signature of stack the following function.</p> <pre><code>    showstack::(*-&gt;[char])-&gt;stack *-&gt;[char]\n</code></pre> <p>To obtain the output format illustrated above, an appropriate definition of showstack would be,</p> <pre><code>    showstack f [] = \"empty\"\n    showstack f (a:x) = \"(push \" ++ f a ++ \" \" ++ showstack f x ++ \")\"\n</code></pre> <p>If this definition is included in the script, stacks  become  printable, using  the  specified  format.  The effect is to extend the behaviour of the special built-in function  show  to  handle  stacks,  and  all  data structures  built using stacks (such as list of tree of stacks, stack of stacks and so on).</p> <p>The general rule is as follows.  Let <code>foo</code> be an abstract type name.  To make foo's printable, we need to define a <code>showfoo</code> thus:</p> <pre><code>    if foo is a simple type (not polymorphic)\n    showfoo :: foo -&gt; [char]\n\n    if foo is polymorphic in one type variable (foo *)\n    showfoo :: (*-&gt;[char]) -&gt; foo * -&gt; [char]\n\n    if foo is polymorphic in two type variables (foo * **)\n    showfoo :: (*-&gt;[char]) -&gt; (**-&gt;[char]) -&gt; foo * ** -&gt; [char]\n</code></pre> <p>and so on.  Note  that  the  show  function  must  be  declared  in  the signature  of  the  abstract  type, and that the name of the function is significant - if we change its name from  <code>showfoo'  to</code>gobbledegook`, its  definition  will cease to have any effect on the behaviour of show. It also needs to have the right type, and if  it  does  not,  again  its presence  will have no effect on the behaviour of show (in this case the compiler prints a warning message).</p> <p>[Note on library directives: If you %export an abstract type,  foo  say, to  another  file,  it  is not necessary to %export the showfoo function explicitly to preserve the correct printing behaviour - if  an  abstract type  comes  into  existence  with  a show function in its signature the compiler will <code>remember</code> how to print objects of the type even in scopes where the show function has no name.]</p>"},{"location":"22/","title":"Empty types (also called Placeholder types)","text":"<p>An empty type has no values belonging to it (apart  from  the  undefined value,  undef,  which  is  a  member  of  every  type).  Empty types are declared as follows:</p> <pre><code>    widget :: type\n</code></pre> <p>this declares <code>widget</code> to be a type but gives it no values.</p> <p>Empty types can be used during program development as  placeholders  for types  whose  representation  is not yet decided.  For example given the above declaration we can give type specifications involving widget, e.g.</p> <pre><code>    foo :: num-&gt;widget-&gt;widget\n    gronk :: [widget]-&gt;widget\n</code></pre> <p>and write code using <code>foo' and</code>gronk` which can  be  checked  for  type correctness.   At  a later stage the specification of widget as an empty type can be replaced by a non-empty type definition using  ==,  ::=,  or abstype, allowing foo, gronk, to be defined.</p> <p>Typenames declared as empty can have any arity, eg</p> <pre><code>    table * ** :: type\n</code></pre> <p>This creates a family of empty types, such as <code>table num  bool</code>  and  so on.  They are all devoid of values (apart from undef).  The general form of this kind of specification is</p> <pre><code>    tform-list :: type\n</code></pre> <p>where <code>tform</code> consists of a typename followed by zero  or  more  generic type  variables  (and  it  is  permitted  to  declare several such types simultaneously, separated by commas, whence <code>tform-list</code>).</p> <p>An empty type may be considered equivalent to an algebraic type with  no constructors.</p>"},{"location":"23/","title":"Show","text":"<p>The use of <code>show</code> for converting objects to their print representations</p> <p>The need often arises to convert an arbitrary Miranda value to its printable representation as a string. For numbers the function <code>shownum</code> (of type num-&gt;[char]) can be used for this purpose. To be able to do this conversion for any type of object would seemingly require an infinite number of functions, one for each type. As a solution to this problem Miranda provides a special keyword, <code>show</code>.</p> <p>For any object x</p> <pre><code>        show x\n</code></pre> <p>is a string containing the printable representation of x. For example, if x is a number the above expression is equivalent to <code>shownum x</code>. In the general case, however, x could be a structured object of arbitrary complexity. Note that show is a reserved word, not an identifier.</p> <p>In fact <code>show</code> behaves under most circumstances as though it was the name of a function, of type <code>*-&gt;[char]</code>. For example it can be passed as a parameter, so that say,</p> <pre><code>        map show [a,b,c,d,e]\n</code></pre> <p>is a legal expression of type [[char]].</p> <p>There are three important restrictions on the universality of show.</p> <p>(i) You cannot <code>show</code> functions in any useful sense. (That would be a violation of referential transparency.) The result of applying show to any kind of function is just the string \\\"\\&lt;function&gt;\\\".</p> <p>(ii) You cannot <code>show</code> an abstract object unless an appropriate show-function was included when the type was defined (see manual section on Abstract types). The result of applying show to such an object is by default just the string \\\"\\&lt;abstract ob&gt;\\\".</p> <p>(iii) When it occurs in a script the context in which show is used must be such as to determine its type [monomorphically]{.underline}. An example:</p> <pre><code>        my_show x = \"hello\\n\"++show x++\"goodbye\\n\"\n</code></pre> <p>In the absence of any other type information, the compiler will infer that my_show has type *-&gt;[char], and that x is of type <code>\\*</code>. The use of show is therefore polymorphic, and will be rejected as illegal.</p> <p>If however we intend that my_show will be used only on objects of type <code>tree</code>, say, and we add to the script the declaration <code>my_show::tree-\\&gt;\\[char\\]</code>, then the above use of show becomes monomorphic, and will be accepted.</p> <p>The essence of restriction (iii) is that show is not a true polymorphic function of type *-&gt;[char], but rather a family of monomorphic functions with the types T-&gt;[char] for each possible monotype T. The context must be sufficient for the compiler to determine which member of the family is required.</p> <p>(For technical reasons this restriction applies only in scripts. In command-level expressions show behaves as if it were a genuine polymorphic function.)</p>"},{"location":"24/","title":"Syntax of Miranda scripts and expressions","text":"<pre><code>script:= decl*                          rhs:= simple_rhs(;)\n                                              cases\ndecl:= def\n       tdef                             simple_rhs:= exp whdefs?\n       spec\n       libdir                           cases:= alt(;) = cases\n                                                lastcase(;)\ndef:= fnform = rhs\n      pat = rhs                         alt:= exp , if? exp\n\ntdef:= tform == type(;)                 lastcase:= lastalt whdefs?\n       tform ::= constructs(;)\n       abstype tform-list with sig(;)   lastalt:= exp , if? exp\n                                                  exp , otherwise\nspec:= var-list :: type(;)\n       tform-list :: type(;)            whdefs:= where def def*\n\nsig:= spec spec*                        exp:= e1\n                                              prefix1\nconstructs:= construct | constructs           infix\n             construct\n                                        e1:= simple simple*\nconstruct:= constructor argtype*             prefix e1\n            type $constructor type           e1 infix e1\n            ( construct ) argtype*\n                                        simple:= var\ntype:= argtype                                   constructor\n       typename argtype*                         literal\n       type -&gt; type                              readvals\n       type $typename type                       show\n                                                 ( infix1 e1 )\nargtype:= typename                               ( e1 infix )\n          typevar                                ( exp-list? )\n          ( type-list? )                         [ exp-list? ]\n          [ type-list ]                          [ exp .. exp? ]\n                                                 [ exp , exp .. exp? ]\ntform:= typename typevar*                        [ exp | qualifs ]\n        typevar $typename typevar                [ exp // qualifs ]\n\nfnform:= var formal*                    qualifs:= qualifier ; qualifs\n         pat $var pat                             qualifier\n         ( fnform ) formal*\n                                        qualifier:= exp\npat:= formal                                        generator\n      -numeral\n      constructor formal*               generator:= pat-list &lt;- exp\n      pat : pat                                     pat &lt;- exp , exp ..\n      pat + nat\n      pat $constructor pat              var:= identifier\n      ( pat ) formal*\n                                        constructor:= IDENTIFIER\nformal:= var\n         constructor                    typename:= identifier\n         literal1\n         ( pat-list? )\n         [ pat-list? ]\n</code></pre>"},{"location":"25/","title":"Comments on the syntax for Miranda scripts","text":"<p>The syntax equations given express the syntax of Miranda scripts insofar as  this  can  be done by a context free grammar.  It therefore does not attempt to express the scope rules, nor the requirement that a script be well-typed,  both  of  which  are  context sensitive restrictions on the syntax given here.  The formal definition of  Miranda  [in  preparation] will  deal with these matters and also give a denotational semantics for the language.</p> <p>Nevertheless, if the syntax is read in  conjunction  with  the  informal description  of  the  language (see other manual sections and referenced papers) it should be found fairly informative, especially if the  reader has some previous exposure to this style of language.</p> <p>Key to abbreviations in syntax:-</p> <pre><code>    &gt;    alt=alternative            decl=declaration    def=definition\n    &gt;    e1=operator_expression     exp=expression      fnform=function_form\n    &gt;    libdir=library_directive   pat=pattern         qualifs=qualifiers\n    &gt;    rhs=right_hand_side        sig=signature       spec=specification\n    &gt;    tdef=type_definition       tform=typeform      var=variable\n    &gt;    whdefs=where_defs\n</code></pre>"},{"location":"25/#conventions","title":"Conventions","text":"<p>We use a variant of BNF, in  which  non-terminals  are  represented  by lower case words, <code>:=</code> is used as the production symbol, and alternative productions are written on successive  lines.   (These  departures  from convention are adopted because <code>::=' and</code>|` are concrete symbols of the language.)</p> <p>For any non-terminal x,</p> <pre><code>    x*      means zero or more occurrences of x\n    x?      means the presence of x is optional\n    x-list  means one or more x's (separated by commas if &gt;1)\n    x(;)    means that  x  is  followed by an optional semicolon and\n    is subject to the offside rule (see section on Layout),  so  that  every\n    token  of  x  must lie below or to the right of the first.  Provided the\n    layout makes it clear where x terminates, the trailing semicolon may  be\n    omitted.\n</code></pre> <p>Notes</p> <p>The syntax of  the  library  directives  (denoted  by  the  non-terminal <code>libdir</code>) is given in a separate manual entry.</p> <p>Ambiguities  in  the  syntax  for <code>type' and</code>construct<code>are resolved by noting that</code>-&gt;' is less binding than <code>$typename' or</code>$constructor`  and that all three are right associative.</p> <p>In connection with the productions for argtype, note that type  such  as <code>[num,bool]'  is  an  abbreviation for</code>[(num,bool)]` and represents the type of a list of tuples - the Miranda system  itself  never  uses  this abbreviation when printing a type, but accepts it in user scripts.  (Use of this abbreviation is not recommended - it will  probably  be  removed from the syntax at the next release.)</p> <p>Ambiguities in the syntax for <code>fnform' and</code>pat<code>are resolved by  taking into  account  the  relative  binding  powers  of  the  infix  operators involved.  Specifically that</code>:<code>is right associative and  less  binding than</code>+`, which is left associative, and that $constructor, $var have a higher binding power than either of these, and are right associative.</p> <p>The productions given for <code>cases</code> correctly describe the concrete syntax of  these  entities,  including  the  way the offside rule is applied to them.  This concrete syntax is in one sense misleading, however.  Namely in  that  if  a  <code>lastcase' with a trailing</code>wheredefs<code>is preceded by a series of alternatives, the scope of the names introduced by  the  where IS THE WHOLE</code>cases' IN WHICH IT OCCURS, AND NOT JUST THE <code>lastcase</code>.</p> <p>Note that for compatibility with earlier versions of Miranda the use  of the keyword <code>if</code> is optional.</p> <p>The ambiguities in the syntax given for <code>e1</code> are resolved by taking into account the relative binding powers of the operators (see manual section on Operators).</p> <p>The syntax of identifier, IDENTIFIER, literal, literal1,  numeral,  nat, infix,  infix1,  prefix,  prefix1,  and  typevar are given under Lexical Syntax (see next manual section).</p>"},{"location":"26/","title":"Miranda lexical syntax","text":"<p>In this section square brackets are used to enclose a  set  of  literal characters,  using lex-style conventions, so eg [a-z] means a lower case letter.   As  usual  *  and  ?   are  used  to  mean  zero-or-more,  and zero-or-one,  occurrences of the preceding entity.  Parentheses are used for grouping, and subtraction of one syntactic entity from another means set  difference.   We  also  revert to using <code>|</code> for alternatives, as in standard BNF.</p> <pre><code>    script:= (token | layout)*\n\n    layout:= nl | tab | formfeed | space | comment\n\n    comment:= vertical_bar vertical_bar (any - nl)* nl\n\n    token:= identifier | IDENTIFIER | literal | typevar | delimiter\n\n    identifier:= ([a-z] [a-zA-Z0-9_']* ) -  delimiter\n\n    IDENTIFIER:= [A-Z] [a-zA-Z0-9_']*\n\n    literal:= numeral | charconst | stringconst\n\n    literal1:= literal - float\n\n    numeral:= nat | float\n\n    nat:= [0-9] [0-9]*\n\n    float:=  [0-9]* [.] nat epart? | nat epart\n\n    epart:= [e] [+|-]? nat\n\n    charconst:= ['] (visible-[\\]|escape) [']\n\n    stringconst:= [\"] (visible-[\\\"]|escape)* [\"]\n\n    escape:= [\\] ([ntfrb\\'\"]|nl|ascii_code)\n\n    typevar:= [*][*]*\n\n    delimiter:= - | prefix1 | infix1 | other\n\n    infix1:= ++ | -- | : | \\/ | &amp; | &gt; | &gt;= | = | ~= | &lt;= | &lt; | + | * |\n            / | div | mod | ^ | . | ! | $identifier | $IDENTIFIER\n\n    infix:= infix1 | -\n\n    prefix1:= ~ | #\n\n    prefix:= prefix1 | -\n\n    other:= abstype | if | otherwise | readvals | show | type | where |\n            with | %export | %free | %include | %insert | %list | %nolist |\n            = | == | ::= | :: | =&gt; | vertical_bar | // | -&gt; | ; | , | ( |\n            ) | [ | ] | { | } | &lt;- | .. | $$ | $- | $+ | $*\n\n    vertical_bar:= |\n</code></pre> <p>Notes</p> <p>visible means any  non-control  character,  including  space  (but  not including eg newline), nl means literal newline, and ascii_code is a nat in the range 0..255 (maximum length 3 digits).</p> <p>Notice that the syntax of <code>numeral</code> does not include  negative  numbers. Negative  constants,  such  as  -3 or -5.05e-17 are parsed by Miranda as applications of the prefix operator <code>-</code> to a positive numeral.  This has no semantic significance.</p> <p>Omission - the definition of <code>layout</code> does not  include  the  additional comment rules for LITERATE SCRIPTS (see separate manual section).</p>"},{"location":"28/","title":"The Miranda Standard Environment","text":"<p>We give here, in alphabetical order, a brief explanation of all the identifiers in the Miranda standard environment, each followed by its definition (except in a few cases where the definition cannot conveniently be given in Miranda). The lines marked with a <code>\\&gt;</code> in column one are formal program text, the other lines in the file are comment. Note that a number of the functions given here are defined internally (for speed) even though their definitions could have been given in Miranda - in these cases the Miranda definition is given as a comment. This is the standard environment of Miranda release two.</p> <p><code>abs</code> takes the absolute value of a number - e.g. abs (-3) is 3, abs 3.5 is 3.5</p> <pre><code>&gt; abs :: num-&gt;num\n&gt; abs x = -x, if x&lt;0\n&gt;       =  x, otherwise\n</code></pre> <p><code>and</code> applied to a list of truthvalues, takes their logical conjunction.</p> <pre><code>&gt; and :: [bool]-&gt;bool\n&gt; and = foldr (&amp;) True\n</code></pre> <p><code>arctan</code> is the trigonometric function, inverse tangent. It returns a result in the range -pi/2 to pi/2. See also <code>sin\\',</code>cos`.</p> <pre><code>&gt; arctan :: num-&gt;num ||defined internally\n</code></pre> <p><code>bool</code> is the type comprising the two truthvalues.</p> <pre><code>        bool ::= False | True ||primitive to Miranda\n</code></pre> <p><code>char\\' is the type comprising ascii characters (e.g. \\'a\\', \\'\\\\n</code>).</p> <pre><code>        char :: type ||primitive to Miranda\n</code></pre> <p><code>cjustify</code> applied to a number and a string, centre justifies the string in a field of the specified width. See also <code>ljustify</code>, <code>rjustify\\',</code>spaces`.</p> <pre><code>&gt; cjustify :: num-&gt;[char]-&gt;[char]\n&gt; cjustify n s = spaces lmargin++s++spaces rmargin\n&gt;                where\n&gt;                margin = n - # s\n&gt;                lmargin = margin div 2\n&gt;                rmargin = margin - lmargin\n</code></pre> <p><code>code</code> applied to a character returns the integer which is its ascii code. E.g.</p> <pre><code>        code 'a' = 97.\n</code></pre> <p>See also <code>decode</code>.</p> <pre><code>&gt; code :: char-&gt;num  ||defined internally\n</code></pre> <p><code>concat</code> applied to a list of lists, joins them all together into a single list with <code>++</code>. E.g.</p> <pre><code>        concat [[1,2],[],[3,4]] = [1,2,3,4].\n\n&gt; concat :: [[*]]-&gt;[*]\n&gt; concat = foldr (++) []\n</code></pre> <p><code>const</code> is a combinator for creating constant-valued functions. E.g. (const 3) is the function that always returns 3.</p> <pre><code>&gt; const :: *-&gt;**-&gt;*\n&gt; const x y = x\n</code></pre> <p><code>converse</code> is a combinator for inverting the order of arguments of a two-argument function.</p> <pre><code>&gt; converse :: (*-&gt;**-&gt;***)-&gt;**-&gt;*-&gt;***\n&gt; converse f a b = f b a\n</code></pre> <p><code>cos</code> is the trigonometric cosine function, argument in radians.</p> <pre><code>&gt; cos :: num-&gt;num   ||defined internally\n</code></pre> <p><code>decode</code> applied to a number between 0 and 255 returns the corresponding value of type char.</p> <pre><code>&gt; decode :: num-&gt;char ||defined internally\n</code></pre> <p><code>digit</code> is a predicate on characters. True if the character is a digit. See also <code>letter</code>.</p> <pre><code>&gt; digit :: char-&gt;bool\n&gt; digit x = '0'&lt;=x&lt;='9'\n</code></pre> <p><code>drop</code> applied to a number and a list returns the list with that many elements removed from the front. If the list has less than the required number of elements, <code>drop</code> returns []. Example</p> <pre><code>        drop 2 [1,2,3,4] = [3,4]\n</code></pre> <p>See also <code>take</code>.</p> <pre><code>&gt; drop :: num-&gt;[*]-&gt;[*]  ||defined internally, as below\n\n  drop (n+1) (a:x) = drop n x\n  drop n x = x,                                         if integer n\n           = error \"drop applied to fractional number\", otherwise\n</code></pre> <p><code>dropwhile</code> applied to a predicate and a list, removes elements from the front of the list while the predicate is satisfied. Example:</p> <pre><code>        dropwhile digit \"123gone\" = \"gone\"\n</code></pre> <p>See also <code>takewhile</code>.</p> <pre><code>&gt; dropwhile :: (*-&gt;bool)-&gt;[*]-&gt;[*]\n&gt; dropwhile f [] = []\n&gt; dropwhile f (a:x) = dropwhile f x, if f a\n&gt;                   = a:x,           otherwise\n</code></pre> <p><code>e</code> is a transcendental number, the base of natural logarithms.</p> <pre><code>&gt; e :: num\n&gt; e = exp 1\n</code></pre> <p><code>entier</code> when applied to a number returns its integer part, meaning the largest integer not exceeding it. E.g.</p> <pre><code>        entier 1.0 = 1\n        entier 3.5 = 3\n        entier (-3.5) = -4.\n</code></pre> <p>Notice that for Miranda the number <code>1\\' and the number</code>1.0<code>are different values - for example they yield different results under the</code>integer\\' test. However <code>1=1.0</code> is True, because of the automatic conversion from integer to float.</p> <pre><code>&gt; entier :: num-&gt;num  ||defined internally\n</code></pre> <p>A useful fact about <code>entier</code>, which relates it to the operators div and mod, is that the following law holds for any integers a, b with b\\~=0 and a/b within the range for which integers can be represented exactly as fractional numbers</p> <pre><code>        a div b = entier (a/b)\n</code></pre> <p><code>error</code> applied to a string creates an error value with the associated message. Error values are all equivalent to the undefined value - any attempt to access the value causes the program to terminate and print the string as a diagnostic.</p> <pre><code>&gt; error :: [char]-&gt;*  ||defined internally\n</code></pre> <p><code>exp\\' is the exponential function on real numbers. See also</code>log`.</p> <pre><code>&gt; exp :: num-&gt;num   ||defined internally\n</code></pre> <p><code>filemode</code> applied to a string representing the pathname of a UNIX file, returns a string of length four giving the access permissions of the current process to the file. The permissions are encoded as (in this order) \\\"drwx\\\", any permission not granted is replaced by a \\'-\\' character. If there is no file at pathname p, filemode p returns the empty string. Example</p> <pre><code>        member (filemode f) 'w'\n</code></pre> <p>tests f for write permission. See also <code>getenv\\',</code>read\\', <code>system</code>.</p> <pre><code>&gt; filemode :: [char]-&gt;[char]  ||defined internally\n</code></pre> <p><code>filter</code> applied to a predicate and a list, returns a list containing only those elements that satisfy the predicate. Example</p> <pre><code>        filter (&gt;5) [3,7,2,8,1,17] = [7,8,17]\n\n&gt; filter :: (*-&gt;bool)-&gt;[*]-&gt;[*]\n&gt; filter f x = [a | a&lt;-x; f a]\n</code></pre> <p><code>foldl</code> folds up a list, using a given binary operator and a given start value, in a left associative way. Example:</p> <pre><code>        foldl op r [a,b,c] = (((r $op a) $op b) $op c)\n</code></pre> <p>But note that in order to run in constant space, foldl forces <code>op</code> to evaluate its first parameter. See the definitions of <code>product</code>, <code>reverse\\',</code>sum\\' for examples of its use. See also <code>foldr</code>.</p> <pre><code>&gt; foldl :: (*-&gt;**-&gt;*)-&gt;*-&gt;[**]-&gt;*  ||defined internally, as below\n\n  foldl op r [] = r\n  foldl op r (a:x) = strict (foldl op) (op r a) x\n                     where\n                     strict f x = seq x (f x)\n</code></pre> <p>WARNING - this definition of foldl differs from that in older versions of Miranda. The one here is the same as that in Bird and Wadler (1988). The old definition had the two args of <code>op</code> reversed. That is:-</p> <pre><code>        old_foldl op r = new_foldl (converse op) r\n</code></pre> <p>the function <code>converse</code> has been added to the standard environment.</p> <p><code>foldl1</code> folds left over non-empty lists. See the definitions of <code>max\\',</code>min` for examples of its use.</p> <pre><code>&gt; foldl1 :: (*-&gt;*-&gt;*)-&gt;[*]-&gt;*  ||defined internally, as below\n\n  foldl1 op (a:x) = foldl op a x\n  foldl1 op [] = error \"foldl1 applied to []\"\n</code></pre> <p><code>foldr</code> folds up a list, using a given binary operator and a given start value, in a right associative way. Example:</p> <pre><code>        foldr op r [a,b,c] = a $op (b $op (c $op r))\n</code></pre> <p>See the definitions of <code>and\\',</code>concat\\', <code>or</code>, for examples of its use.</p> <pre><code>&gt; foldr :: (*-&gt;**-&gt;**)-&gt;**-&gt;[*]-&gt;** ||defined internally, as below\n\n  foldr op r [] = r\n  foldr op r (a:x) = op a (foldr op r x)\n</code></pre> <p><code>foldr1</code> folds right over non-empty lists.</p> <pre><code>&gt; foldr1 :: (*-&gt;*-&gt;*)-&gt;[*]-&gt;*\n&gt; foldr1 op [a] = a\n&gt; foldr1 op (a:b:x) = op a (foldr1 op (b:x))\n&gt; foldr1 op [] = error \"foldr1 applied to []\"\n</code></pre> <p><code>force</code> applied to any data structure, returns it, but forces a check that every part of the structure is defined. Example</p> <pre><code>        hd(force x)\n</code></pre> <p>returns the hd of x, but fully evaluates x first (so x must be finite). See also <code>seq\\'. Notice in particular the idiom</code>seq (force a) b<code>which returns</code>b\\' but only after fully evaluating <code>a</code>.</p> <pre><code>&gt; force :: *-&gt;* ||defined internally\n</code></pre> <p><code>fst\\' returns the first component of a pair. See also</code>snd`.</p> <pre><code>&gt; fst :: (*,**)-&gt;*\n&gt; fst (a,b) = a\n</code></pre> <p><code>getenv\\' looks up a string in the user</code>s UNIX environment. Example</p> <pre><code>        getenv  \"HOME\"\n</code></pre> <p>returns the pathname of your home directory. [If you want to see what else is in your UNIX environment, say <code>printenv</code> as a UNIX command.]</p> <pre><code>&gt; getenv :: [char]-&gt;[char]   ||defined internally\n</code></pre> <p><code>hd</code> applied to a non empty list, returns its first element. It is an error to apply <code>hd\\' to the empty list, \\[\\]. See also</code>tl`.</p> <pre><code>&gt; hd :: [*]-&gt;*\n&gt; hd (a:x) = a\n&gt; hd [] = error \"hd []\"\n</code></pre> <p><code>hugenum</code> is the largest fractional number that can exist in this implementation (should be around 1e308 for IEEE standard 64 bit floating point). See also <code>tinynum</code>.</p> <pre><code>&gt; hugenum :: num  ||defined internally\n</code></pre> <p><code>id</code> is the identity function - applied to any object it returns it.</p> <pre><code>&gt; id :: *-&gt;*\n&gt; id x = x\n</code></pre> <p><code>index</code> applied to a (finite or infinite) list, returns a list of its legal subscript values, in ascending order. E.g. index \\\"hippopotamus\\\" is [0,1,2,3,4,5,6,7,8,9,10,11].</p> <pre><code>&gt; index :: [*]-&gt;[num]\n&gt; index x = f 0 x\n&gt;           where\n&gt;           f n [] = []\n&gt;           f n (a:x) = n:f(n+1)x\n</code></pre> <p><code>init\\' is dual to</code>tl`, it returns a list without its last component. Example</p> <pre><code>        init [1,2,3,4] = [1,2,3].\n</code></pre> <p>See also <code>last\\'. \\[Note, by the</code>dual` of a list processing function we mean the function which does the same job in a world where all lists have been reversed.]</p> <pre><code>&gt; init :: [*]-&gt;[*]\n&gt; init (a:x) = [],       if x=[]\n&gt;            = a:init x, otherwise\n&gt; init [] = error \"init []\"\n</code></pre> <p><code>integer</code> is a predicate on numbers. True if and only if the number is not fractional.</p> <pre><code>&gt; integer :: num-&gt;bool    ||defined internally\n</code></pre> <p>[<code>iterate</code> - iterate f x returns the infinite list [x, f x, f(f x), ... ] Example, iterate (2*) 1 yields a list of the powers of 2. In the definition note use of \\\", ..\\\" to express a recurrence relation (see manual section 13/2).]{#iterate}</p> <pre><code>&gt; iterate :: (*-&gt;*)-&gt;*-&gt;[*]\n&gt; iterate f x = [y | y&lt;-x, f y ..]\n</code></pre> <p><code>last</code> applied to a non empty list returns its last element. This function is the dual of <code>hd</code>. Note that for any non-empty list x</p> <pre><code>        (init x ++ [last x]) = x\n\n&gt; last :: [*]-&gt;*    ||defined internally, as below\n\n  last x = x!(#x-1)\n</code></pre> <p><code>lay</code> applied to a list of strings, joins them together after appending a newline character to each string. Example</p> <pre><code>        lay [\"hello\",\"world\"] = \"hello\\nworld\\n\"\n</code></pre> <p>Used to format output thus,</p> <pre><code>        lay(map show x)\n</code></pre> <p>as a top level expression, causes the elements of the list x to be printed one per line. See also <code>layn\\',</code>lines`.</p> <pre><code>&gt; lay :: [[char]]-&gt;[char]\n&gt; lay [] = []\n&gt; lay (a:x) = a++\"\\n\"++lay x\n</code></pre> <p><code>layn\\' is similar to</code>lay`, but produces output with numbered lines.</p> <pre><code>&gt; layn :: [[char]]-&gt;[char]\n&gt; layn x =   f 1 x\n&gt;            where\n&gt;            f n [] = []\n&gt;            f n (a:x) = rjustify 4 (show n) ++\") \"++a++\"\\n\"++f (n+1) x\n</code></pre> <p>\\'letter\\' is a predicate on characters. True if the character is a letter.</p> <pre><code>&gt; letter :: char-&gt;bool\n&gt; letter c = 'a'&lt;=c&lt;='z' \\/ 'A'&lt;=c&lt;='Z'\n</code></pre> <p><code>limit</code> applied to a list of values, returns the first value which is the same as its successor. Useful in testing for convergence. For example the following Miranda expression computes the square root of 2 by the Newton-Raphson method</p> <pre><code>        limit [x | x&amp;lt;-2, 0.5*(x + 2/x).. ]\n\n&gt; limit :: [*]-&gt;*\n&gt; limit (a:b:x) = a,           if a=b\n&gt;               = limit (b:x), otherwise\n&gt; limit other = error \"incorrect use of limit\"\n</code></pre> <p><code>lines</code> applied to a list of characters containing newlines, returns a list of lists, by breaking the original into lines. The newline characters are removed from the result. Example, <code>lines</code> applied to</p> <pre><code>        \"hello world\\nit's me,\\neric\\n\"\n</code></pre> <p>returns [\\\"hello world\\\",\\\"it\\'s me\\\",\\\"eric\\\"]. Note that <code>lines</code> treats newline as a terminator, not a separator (although it will tolerate a missing \\'\\n\\' on the last line).</p> <pre><code>&gt; lines :: [char]-&gt;[[char]]\n&gt; lines [] = []\n&gt; lines (a:x) = []:lines x,   if a='\\n'\n&gt;             = (a:x1):xrest, otherwise\n&gt;               where \n&gt;               (x1:xrest) = lines x, if x~=[]\n&gt;                          = []:[],   otherwise\n&gt;                            ||this handles missing '\\n' on last line\n</code></pre> <p>Note that the inverse of <code>lines\\' is the function</code>lay<code>, in that applying</code>lay\\' to the output of <code>lines</code> will restore the original string (except that a final newline will be added, if missing in the original string).</p> <p><code>ljustify</code> applied to a number and a string, left justifies the string in a field of the specified width.</p> <pre><code>&gt; ljustify :: num-&gt;[char]-&gt;[char]\n&gt; ljustify n s = s++spaces(n - # s)\n</code></pre> <p><code>log</code> applied to a number returns its natural logarithm (i.e. logarithm to the base <code>e</code>). It is the inverse of the exponential function, <code>exp</code>. See also log10. Note that the log functions use a different algorithm when applied to integer arguments (rather than just converting to float first) so it is possible to take log, or log10, of very large integers.</p> <pre><code>&gt; log :: num-&gt;num      ||defined internally\n</code></pre> <p><code>log10</code> applied to a number returns its logarithm to the base 10.</p> <pre><code>&gt; log10 :: num-&gt;num      ||defined internally\n</code></pre> <p><code>map</code> applied to a function and a list returns a copy of the list in which the given function has been applied to every element.</p> <pre><code>&gt; map :: (*-&gt;**)-&gt;[*]-&gt;[**]\n&gt; map f x = [f a | a&lt;-x]\n</code></pre> <p><code>map2\\' is similar to</code>map<code>, but takes a function of two arguments, and maps it along two argument lists. We could also define</code>map3<code>,</code>map4` etc., but they are much less often needed.</p> <pre><code>&gt; map2 :: (*-&gt;**-&gt;***)-&gt;[*]-&gt;[**]-&gt;[***]\n&gt; map2 f x y = [f a b | (a,b)&lt;-zip2 x y]\n</code></pre> <p>Note: the Bird and Wadler function <code>zipwith</code> is just an uncurried version of <code>map2\\', that is</code>zipwith f (x,y)\\' means <code>map2 f x y</code>.</p> <p><code>max</code> applied to a list returns the largest element under the built in ordering of <code>\\&gt;</code>. Examples</p> <pre><code>        max [1,2,12,-6,5] = 12\n        max \"hippopotamus\" = 'u'\n</code></pre> <p>See also <code>min\\',</code>sort`.</p> <pre><code>&gt; max :: [*]-&gt;*\n&gt; max = foldl1 max2\n</code></pre> <p><code>max2</code> applied to two values of the same type returns the larger under the built in ordering of \\'&gt;\\'. See also <code>min2</code>.</p> <pre><code>&gt; max2 :: *-&gt;*-&gt;*\n&gt; max2 a b = a, if a&gt;=b\n&gt;          = b, otherwise\n</code></pre> <p><code>member</code> applied to a list and a value returns True or False as the value is or not present in the list.</p> <pre><code>&gt; member :: [*]-&gt;*-&gt;bool\n&gt; member x a = or (map (=a) x)\n</code></pre> <p><code>merge</code> applied to two sorted lists merges them to produce a single sorted result. Used to define <code>sort</code>, see later.</p> <pre><code>&gt; merge :: [*]-&gt;[*]-&gt;[*]  ||defined internally, as below\n\n  merge [] y = y\n  merge (a:x) [] = a:x\n  merge (a:x) (b:y) = a:merge x (b:y), if a&lt;=b\n                    = b:merge (a:x) y, otherwise\n</code></pre> <p><code>min\\' applied to a list returns its least member under</code>\\&lt;`.</p> <pre><code>&gt; min :: [*]-&gt;*\n&gt; min = foldl1 min2\n</code></pre> <p><code>min2</code> applied to two values of the same type returns the smaller under the built in ordering of \\'\\&lt;\\'.</p> <pre><code>&gt; min2 :: *-&gt;*-&gt;*\n&gt; min2 a b = b, if a&gt;b\n&gt;          = a, otherwise\n</code></pre> <p><code>mkset</code> applied to a list returns a copy of the list from which any duplicated elements have been removed. A list without duplications can be used to represent a set, whence the name. Works even on infinite list, but (beware) takes a time quadratic in the number of elements processed.</p> <pre><code>&gt; mkset :: [*]-&gt;[*]\n&gt; mkset [] = []\n&gt; mkset (a:x) = a:filter (~=a) (mkset x)\n</code></pre> <p><code>neg</code> is a function of one numeric argument, with the same action as the unary <code>-</code> operator.</p> <pre><code>&gt; neg :: num-&gt;num\n&gt; neg x = -x\n</code></pre> <p><code>num</code> is the type comprising both integer and fractional numbers (such as 42, -12.73e8).</p> <pre><code>        num :: type  ||primitive to Miranda\n</code></pre> <p><code>numval</code> converts a numeric string to the corresponding number - can cope with sign, decimal point and scale factor (uses same rules as Miranda compiler). Strings containing inappropriate characters cause an error (exception - leading white space is harmless).</p> <pre><code>&gt; numval :: [char]-&gt;num ||defined internally\n</code></pre> <p><code>or</code> applied to a list of truthvalues, takes their logical disjunction.</p> <pre><code>&gt; or :: [bool]-&gt;bool\n&gt; or = foldr (\\/) False\n</code></pre> <p><code>pi</code> is the well known real number (the ratio of the circumference of a circle to its diameter).</p> <pre><code>&gt; pi :: num\n&gt; pi = 4*arctan 1\n</code></pre> <p><code>postfix</code> takes an element and a list and adds the element to the end of the list. This is the dual of the prefix operator, <code>:</code>.</p> <pre><code>&gt; postfix :: *-&gt;[*]-&gt;[*]\n&gt; postfix a x = x ++ [a]\n</code></pre> <p><code>product</code> applied to list of numbers returns their product. See also <code>sum</code>.</p> <pre><code>&gt; product :: [num]-&gt;num\n&gt; product = foldl (*) 1\n</code></pre> <p><code>read</code> returns the contents of file with a given pathname. Provides an interface to the UNIX filing system. If the file is empty <code>read</code> returns [], but if the file does not exist, or lacks read permission, <code>read\\' causes an error. See also</code>filemode\\', <code>getenv</code>.</p> <pre><code>&gt; read :: [char]-&gt;[char]  ||defined internally\n</code></pre> <p>readvals is a family of functions for reading a list of values from a file. See manual section 31/3.</p> <p><code>rep</code> applied to a number and a value, returns a list containing the specified number of instances of the value. (The name is short for <code>replicate</code>.) Example</p> <pre><code>        rep 6 'o' = \"oooooo\"\n</code></pre> <p>See also <code>repeat</code>.</p> <pre><code>&gt; rep :: num-&gt;*-&gt;[*]\n&gt; rep n x = take n (repeat x)\n</code></pre> <p><code>repeat</code> applied to a value returns an infinite list, all of whose elements are the given value.</p> <pre><code>&gt; repeat :: *-&gt;[*]\n&gt; repeat x = xs\n&gt;            where xs = x:xs\n</code></pre> <p><code>reverse</code> applied to any finite list returns a list of the same elements in reverse order.</p> <pre><code>&gt; reverse :: [*]-&gt;[*]\n&gt; reverse = foldl (converse(:)) []\n</code></pre> <p><code>rjustify</code> applied to a number and a string, right justifies the string in a field of the specified width.</p> <pre><code>&gt; rjustify :: num-&gt;[char]-&gt;[char]\n&gt; rjustify n s = spaces(n - # s)++s\n</code></pre> <p><code>scan op r\\' applies</code>foldl op r<code>to every initial segment of a list. For example</code>scan (+) 0 x` computes running sums.</p> <pre><code>&gt; scan :: (*-&gt;**-&gt;*)-&gt;*-&gt;[**]-&gt;[*]\n&gt; scan op = g \n&gt;           where\n&gt;           g r = (r:). rest\n&gt;                 where\n&gt;                 rest [] = []\n&gt;                 rest (a:x) = g (op r a) x\n</code></pre> <p>There is another way to explain <code>scan</code>, which makes it clearer why it is useful. Let s0 be the initial state of an automaton, and f::state-&gt;input-&gt;state, its state transition function - then `scan f s0\\' is a function that takes a list of inputs for the automaton and returns the resulting list of states, starting with s0.</p> <p><code>seq</code> applied to two values, returns the second but checks that the first value is not completely undefined. Sometimes needed, e.g. to ensure correct synchronisation in interactive programs.</p> <pre><code>&gt; seq :: *-&gt;**-&gt;** ||defined internally\n</code></pre> <p>show is a keyword denoting a family of functions for converting values of different types to their print representations. See manual section on <code>show</code> for more details.</p> <p><code>shownum</code> applied to a number returns as a string a standard print representation for it. A special case of the operator <code>show</code>. Applied to fractional numbers <code>shownum</code> gives 12 decimal places (less any trailing zeros), using a format appropriate to the size of number. For more detailed control over number format see <code>showfloat</code>, <code>showscaled</code>.</p> <pre><code>&gt; shownum :: num-&gt;[char] ||defined internally,\n</code></pre> <p><code>showfloat p x</code> returns as a string the number x printed in floating point format, that is in the form \\\"digits.digits\\\", where the integer p (&gt;=0) gives the number of digits after the decimal point.</p> <pre><code>&gt; showfloat :: num-&gt;num-&gt;[char] ||defined internally,\n</code></pre> <p><code>showscaled p x</code> returns as a string the number x printed in scientific format, that is in the form \\\"n.nnnnnne[+/-]nn\\\", where the integer p (&gt;=0) gives the number of digits required after the decimal point.</p> <pre><code>&gt; showscaled :: num-&gt;num-&gt;[char] ||defined internally,\n</code></pre> <p><code>sin</code> is the trigonometric sine function, argument in radians.</p> <pre><code>&gt; sin :: num-&gt;num  ||defined internally\n</code></pre> <p><code>snd</code> returns the second component of a pair.</p> <pre><code>&gt; snd :: (*,**)-&gt;**\n&gt; snd (a,b) = b\n</code></pre> <p><code>sort</code> applied to any finite list sorts the elements of the list into ascending order on the built in \\'\\&lt;\\' relation. Note that you cannot sort a list of functions. Example</p> <pre><code>        sort \"hippopotamus\" = \"ahimoopppstu\"\n</code></pre> <p>The following definition uses merge-sort, which has n log n worst-case behaviour.</p> <pre><code>&gt; sort :: [*]-&gt;[*]\n&gt; sort x = x,                                         if n&lt;=1\n&gt;        = merge (sort(take n2 x)) (sort(drop n2 x)), otherwise\n&gt;          where\n&gt;          n = # x\n&gt;          n2 = n div 2\n</code></pre> <p><code>spaces</code> applied to a number returns a list of that many spaces.</p> <pre><code>&gt; spaces :: num-&gt;[char]\n&gt; spaces n = rep n ' '\n</code></pre> <p><code>sqrt</code> is the square root function on (integer or fractional) numbers. The result is always fractional.</p> <pre><code>&gt; sqrt :: num-&gt;num   ||defined internally\n</code></pre> <p><code>subtract</code> is a name for (converse) infix minus. Needed because you cannot form postsections in <code>-\\'. (See manual entry on</code>sections`.) Example</p> <pre><code>        subtract 3\n</code></pre> <p>is the function that subtracts 3.</p> <pre><code>&gt; subtract :: num-&gt;num-&gt;num\n&gt; subtract x y = y - x\n</code></pre> <p><code>sum</code> applied to list of numbers returns their sum.</p> <pre><code>&gt; sum :: [num]-&gt;num\n&gt; sum = foldl (+) 0\n</code></pre> <p><code>sys_message</code> is an algebraic type containing a family of constructors used to control output to UNIX files. See manual section on Output to UNIX files for details.</p> <pre><code>&gt; sys_message ::= Stdout [char] | Stderr [char] | Tofile [char] [char] |\n&gt;                 Closefile [char] | Appendfile [char] | System [char] |\n&gt;                 Exit num\n</code></pre> <p><code>system</code> applied to a string causes the string to be executed as a UNIX shell command (by <code>sh</code>). The result returned is a 3-tuple, comprising the standard_output, error_output, and exit_status respectively, resulting from the execution of the UNIX command. See manual section on Input from UNIX files etc for more details.</p> <pre><code>&gt; system :: [char]-&gt;([char],[char],num)  ||defined internally\n</code></pre> <p><code>take</code> applied to a number and a list returns the specified number of elements from the front of the list. If the list has less than the required number of elements, <code>take</code> returns as many as it can get. Examples</p> <pre><code>        take 2 [1,2,3,4] = [1,2]\n        take 7 \"girls\" = \"girls\"\n\n&gt; take :: num-&gt;[*]-&gt;[*]  ||defined internally, as below\n\n  take (n+1) (a:x) = a : take n x\n  take n x = [],                                        if integer n\n           = error \"take applied to fractional number\", otherwise\n</code></pre> <p><code>takewhile</code> applied to a predicate and a list, takes elements from the front of the list while the predicate is satisfied. Example: takewhile digit \\\"123gone\\\" = \\\"123\\\"</p> <pre><code>&gt; takewhile :: (*-&gt;bool)-&gt;[*]-&gt;[*]\n&gt; takewhile f [] = []\n&gt; takewhile f (a:x) = a:takewhile f x, if f a\n&gt;                   = [],              otherwise\n</code></pre> <p><code>tinynum</code> is the smallest positive fractional number that can be distinguished from zero in this implementation (should be around 1e-324 for IEEE standard 64 bit floating point).</p> <pre><code>&gt; tinynum :: num  ||defined internally\n</code></pre> <p><code>tl</code> applied to a non empty list returns the list without its first element. Example, tl \\\"snow\\\" is \\\"now\\\".</p> <pre><code>&gt; tl :: [*]-&gt;[*]\n&gt; tl (a:x) = x\n&gt; tl [] = error \"tl []\"\n</code></pre> <p><code>transpose</code> applied to a list of lists, returns their transpose (in the sense of matrix transpose - rows and columns are interchanged). Example</p> <pre><code>        transpose [[1,2,3],[4,5,6]] = [[1,4],[2,5],[3,6]]\n</code></pre> <p>The following definition is slightly more subtle than is at first sight necessary, in order to deal correctly with <code>upper triangular</code> matrices. Example</p> <pre><code>        transpose [[1,2,3],[4,5],[6]] = [[1,4,6],[2,5],[3]]\n\n&gt; transpose :: [[*]]-&gt;[[*]]\n&gt; transpose x = [],                             if x'=[]\n&gt;             = map hd x':transpose(map tl x'), otherwise\n&gt;               where\n&gt;               x' = takewhile (~=[]) x\n</code></pre> <p>It might be thought that this function belongs in a specialised library of matrix handling functions, but it has been found useful as a general purpose list processing function, whence its inclusion in the standard environment.</p> <p><code>undef</code> is a name for the completely undefined value. Any attempt access it results in an error message. Note that <code>undef</code> belongs to every type.</p> <pre><code>&gt; undef :: *\n&gt; undef = error \"undefined\"\n</code></pre> <p><code>until</code> applied to a predicate, a function and a value, returns the result of applying the function to the value the smallest number of times necessary to satisfy the predicate. Example</p> <pre><code>        until (&gt;1000) (2*) 1 = 1024\n\n&gt; until :: (*-&gt;bool)-&gt;(*-&gt;*)-&gt;*-&gt;*\n&gt; until f g x = x,               if f x\n&gt;             = until f g (g x), otherwise\n</code></pre> <p><code>zip2</code> applied to two lists returns a list of pairs, formed by tupling together corresponding elements of the given lists. Example</p> <pre><code>        zip2 [0..3] \"type\" = [(0,'t'),(1,'y'),(2,'p'),(3,'e')]\n</code></pre> <p>This function is often useful in list comprehensions, where it provides an idiom for accessing two generators simultaneously. For example the following expression returns the scalar product of x and y (x,y::[num])</p> <pre><code>        sum [ a*b | (a,b) &lt;- zip2 x y ]\n\n&gt; zip2 :: [*]-&gt;[**]-&gt;[(*,**)]  ||defined internally, as below\n\n  zip2 (a:x) (b:y) = (a,b):zip2 x y\n  zip2 x y = []\n</code></pre> <p>Note that if the lists being zipped are of different lengths, the length of the result is that of the shortest list (this holds for zip2 and all the following zip functions).</p> <p>The function <code>zip3</code> is analogous but takes three lists and returns a list of 3-tuples. Similarly for <code>zip4\\',</code>zip5\\', <code>zip6</code> - zip functions above zip6 are not provided in the standard environment.</p> <pre><code>&gt; zip3 (a:x) (b:y) (c:z) = (a,b,c):zip3 x y z\n&gt; zip3 x y z = []\n&gt; zip4 (a:w) (b:x) (c:y) (d:z) = (a,b,c,d):zip4 w x y z\n&gt; zip4 w x y z = []\n&gt; zip5 (a:v) (b:w) (c:x) (d:y) (e:z) = (a,b,c,d,e):zip5 v w x y z\n&gt; zip5 v w x y z = []\n&gt; zip6 (a:u)(b:v)(c:w)(d:x)(e:y)(f:z) = (a,b,c,d,e,f):zip6 u v w x y z\n&gt; zip6 u v w x y z = []\n</code></pre> <p>The following is included for compatibility with Bird and Wadler (1988). The normal Miranda style is to use the curried form <code>zip2</code>.</p> <pre><code>&gt; zip :: ([*],[**])-&gt;[(*,**)]\n&gt; zip (x,y) = zip2 x y\n</code></pre> <p>End of definitions of the standard environment</p>"},{"location":"29/","title":"Literate Scripts","text":"<pre><code>&gt; || Literate scripts (an alternative comment convention)\n\nThe standard comment convention for Miranda  scripts  is  that  anything\nrightwards from a pair of vertical bars to the end of a line is taken to\nbe comment and ignored by the compiler, thus\n        ||This is a comment\n\nEverything else in the script is taken to be formal  program  text.   An\ninverted  style  of  commenting is also available in Miranda, permitting\nthe construction  of  a  \"literate  script\"  (the  name  is  taken  from\nProfessor Donald Knuth's idea of \"literate programming\").  In a literate\nscript EVERYTHING is assumed to be comment, except for lines marked with\nthe formalising symbol '&gt;' in column 1.  For example the following lines\n\n&gt;  fac 0 = 1\n&gt;  fac (n+1) = (n+1)*fac n\n\nwould  be  taken  as  formal program text - and could be preceded and/or\nfollowed by some narrative explaining what the factorial function is and\nwhy we define it in this way.\n\nTo minimise the danger that you will accidentally omit the '&gt;\" from  one\nline of your formal text without the compiler noticing that something is\nwrong, the following additional rule applies to Miranda literate scripts\n-  whenever  a  group  of  lines  of  formal program text is preceded or\nfollowed by some lines of \"narrative\", the two types  of  text  must  be\nseparated  by  at least one blank line.  You will see that this has been\ndone for the definition of  factorial  given  above.   (Definition  -  a\n\"blank line\" is one containing only white space.)\n\nWithin the formal sections of a literate  script  the  standard  comment\nconvention still works.  For example\n\n&gt;  result = sum [fac n | n &lt;- [1..50]]  ||NB this is a large number!\n\nThe  compiler  takes  a  decision on which comment convention applies by\nlooking at the first line of a script.  If this has a '&gt;' in  column  1,\nthen  it  is  a  literate script, otherwise the compiler assumes it is a\nconventional script.  Typically the first line of a literate script will\njust be a comment, eg\n\n&gt; ||This is a literate script\n\nIn fact this manual section is a legal Miranda  script,  defining  `fac`\nand  `result`  (see  first line).\n\nAn alternative convention is based on the name of the  file  -  if  this\nends   in  `.lit.m`  then  it  is  assumed  to  be  a  literate  script,\nindependently of the form of the first line.  This makes it possible  to\nhave literate scripts which begin in `narrative` mode.\n\nAs an aid to maintaining good layout in literate scripts, a simple  text\nformatting  program, called `just` (short for justify), is supplied with\nthe Miranda system.  This leaves untouched the formal  sections  of  the\nscript  and formats the narrative parts to specified width (default 72).\nIf you use `vi' to edit your scripts note that the `just` program can be\ncalled from within the editor by saying, e.g.\n        :1,$!just\n[Warning - do NOT use `just` on non-literate scripts,  it  will  make  a\nmess of them!]\n\nThere is a UNIX manual page  for  `just`  which  gives  details  of  its\nbehaviour  - to see the manual page from within Miranda say `!man just`.\nNote that `just` is a general purpose text formatting tool, and  is  not\nin any way Miranda-specific.\n\nAs an additional aid  to  the  use  of  document  preparation  tools  in\nconjunction  with  Miranda  scripts, the Miranda compiler will recognise\nunderlined keywords.  This applies both to reserved words, such as `div`\nand  `mod'  and  to  directives  such  as  `%export` (underlining of the\ninitial  `%`  is  optional).   The  style  of  underlining  accepted  is\n`backspace-underline-character`  as  generated  by nroff/troff.  It will\nalso recognise the underlined symbols &gt; and &amp;lt; as being equivalent to &gt;=,\n&lt;=  respectively.  This works in both literate scripts and scripts using\nthe standard comment convention.\n\nNote on %insert and literate scripts\n An %insert directive in a literate script will be effective provided it\noccurs  in a line beginning with `&gt;` (otherwise it is a comment and will\nbe ignored).  The inserted text may itself use either  the  standard  or\nthe  literate  comment  convention  (decided by the name of the file and\nwhether or not its first line begins with '&gt;').\n\nSimilarly, text %inserted into a non-literate script may use either  the\nstandard  or  the literate comment convention (again decided by the name\nof the file and the form of its first line).\n\nUsing LaTeX with Miranda literate scripts\n Because of the `.lit.m` convention it is possible for a file to be both\na  Miranda  script and a LaTeX source file.  In such a case the sections\nof formal Miranda text (recognised by the Miranda compiler by the `&gt;` in\ncolumn 1) will be surrounded by the LaTeX commands\n \\begin{verbatim}\n\n \\end{verbatim}\n A similar arrangement can be made for troff.\n\nThis works fine - but you may wish to do even better, and have  reserved\nwords  in  the  Miranda  text  underlined in your printed document.  The\nprogram `mtotex' takes  a  `.m`  file  containing  an  ordinary  Miranda\nliterate  script,  and  creates a `.tex` file of the same name, in which\nvarious LaTeX  commands  have  been  inserted,  including  to  underline\nreserved  words  in program text.  See UNIX manual page for `mtotex` for\ndetails.  Note that the `.tex` file created by mtotex is  not  itself  a\nlegal Miranda script.\n\nAcknowledgements\n The '&gt;' inverse-comment convention (and the \"blank line\" rule) are  due\nto  Richard  Bird  and  Philip  Wadler  of Oxford University Programming\nResearch Group, and were first used in  their  language  \"Orwell\".   The\n`mtotex` program was supplied by John Cupitt of the University of Kent.\n</code></pre>"},{"location":"3/","title":"About this release","text":"<pre><code>About this release\n\nThis is Miranda release two of October 1989 lightly revised in May 2006.\nSome  minor bugs and portability issues have been addressed and parts of\nthe manual rewritten for clarity and to remove  out  of  date  material.\nThe language and main features of the system interface remain unchanged.\n\nMiranda release two had the  following  main  additions,  compared  with\nrelease one\n        the library directive %free (for parametrised scripts)\n        unbounded size integers\nBoth compiler and run time system are also significantly faster.\n\nThe online manual pages are primarily intended to document the system at\nthe  level  required by an experienced user (meaning someone who already\nknows quite a lot about programming and programming  languages  and  has\nsome  previous experience of functional programming). There is a certain\namount of tutorial material, but if you are  a  beginner  to  functional\nprogramming  you  may  find parts of the manual hard to follow, and will\nneed to seek help elsewhere.\n\nThe following paper gives a useful  summary  of  the  main  features  of\nMiranda:\n  D. A. Turner \"An Overview of Miranda\", SIGPLAN Notices, December 1986.\nA copy of this paper is included in the manual pages, but this and other\ninformation about Miranda can be found on the world wide web at\n        miranda.org.uk\n\nThe following text book can be ordered from an internet bookseller\n  Simon Thompson \"Miranda: the Craft of Functional Programming\",\n  Addison-Wesley, 470 pages, 1995.\n        ISBN 0-201-42279-4 (Paperback)\nA webpage for the book by the author is at\n        www.cs.kent.ac.uk/people/staff/sjt/Miranda_craft/\nor follow the link under BOOKS at miranda.org.uk.\n\nAnother good text book is\n  Chris Clack, Colin Myers &amp; Ellen Poon \"Programming with Miranda\",\n  Prentice Hall, 312 pages, 1995.\n        ISBN 0-13-192592-X\nThe rights in this book have reverted to the  authors  who  have  kindly\nmade it available online - follow link under BOOKS at miranda.org.uk.\n\nThe following text book was the one originally recommended for use  with\nMiranda.   It  is  a  tutorial  text  aimed at undergraduates learning a\nfunctional language as their first programming language but  is  equally\nsuitable  for a graduate course on functional programming.  The notation\nused in the book is closely based on Miranda:-\n  Richard Bird &amp; Philip Wadler\n  \"An Introduction to Functional Programming\",\n  Prentice Hall, 293 pages, March 1988.\n        ISBN 13-484189-1 (Cloth)\n        ISBN 13-484197-2 (Paper)\nUnfortunately it is now out of print but it may be  possible  to  obtain\nsecond hand copies or you may find it in a library.\n</code></pre>"},{"location":"30/","title":"Programming Style Guidelines","text":"<p>Functional programming is still at an early  stage  of  development  and some  heterogenity  of  programming  style  is therefore inevitable (and desirable).  Nevertheless a certain amount is known,  and  there  is  no need  for  every  newcomer to functional programming to discover all the pitfalls by trial and  error.   We  give  here  a  series  of  suggested guidelines for good programming style in Miranda.  The list is not meant to be exhaustive.</p> <p>These rules are also not intended to be followed rigidly in  all  cases, regardless  of  conflicting  considerations.   That is why they are only suggestions for good style and not grammar rules. </p> <p>Avoid the indiscriminate use of recursion A Miranda script that consists of large number of functions which call each  other  in  an apparently random fashion is no easier to understand than, say, a piece of FORTRAN code which is written as a rat's  nest  of GOTO  statements.  An excessive reliance on recursion (especially mutual recursion) can be an indication  of  a  weak  programming  style.   Some pointers:</p> <p>Use  list  comprehensions,  <code>..</code>  lists,  and  library   functions,   in preference  to  ad-hoc recursion.  For example it is probably clearer to define factorial by writing</p> <pre><code>    fac n = product[1..n]\n</code></pre> <p>than to define it from first principles, as</p> <pre><code>    fac 0 = 1\n    fac (n+1) = (n+1) * fac n\n</code></pre> <p>and  to  define  the  cartesian  product  of  two  lists   by   a   list comprehension, thus</p> <pre><code>    cp x y = [(a,b)|a&lt;-x;b&lt;-y]\n</code></pre> <p>is certainly a lot clearer than the recursive definition,</p> <pre><code>    cp (a:x) y = f y ++ cp x y\n                    where\n                    f (b:y) = (a,b): f y\n                    f [] = []\n    cp [] y = []\n</code></pre> <p>The standard environment contains a number  of  useful  list  processing functions  (eg  map filter reverse foldr foldl) with whose properties it is worth becoming familiar.  They capture common patterns  of  recursion over  lists, and can often be used to simplify your code, and reduce the reliance on <code>ad-hoc</code> recursion.  Programs using list comprehensions  and standard  functions  are  also  likely  to  run  faster  (on the current implementation) than equivalent programs using ad-hoc recursion.</p> <p>The standard environment is only a basic collection  of  useful  general purpose  functions.   As you get used to programming in Miranda you will probably begin to discover other useful functions  that  express  common patterns  of  recursion (perhaps over data structures other than lists). It is a good practice to collect such functions in  libraries  (together with  some explanations of their properties) so that you can reuse them, and share them with others.  Not all of them will survive  the  test  of time, but it cannot hurt to experiment.</p> <p>To cause the definitions from such a library to be in scope  in  another script  you  would  use  a  <code>%include</code>  directive (see manual section on library directives).</p> <p>Avoid unnecessary nesting of definitions Scripts  that  get  deeply  nested  in  where-clauses  are  harder   to understand,  harder  to  reason about formally, harder to debug (because functions defined inside where's cannot be exercised seperately)  slower to compile, and generally more difficult to work with.</p> <p>A  well  structured  script  will  consist  of  a  series  of  top-level definitions,  each  of which (if it carries a where-clause at all) has a fairly small number of local definitions.  A third level  of  definition (where inside where) should be used only very occasionally.  [And if you find yourself  getting  nested  four  and  five  levels  deep  in  block structure you can be pretty sure that your program has gone badly out of control.]</p> <p>A function should normally be placed inside a where clause only if it is logically  necessary to do so (which will be the case when it has a free variable which is not in scope  outside  the  where  clause).   If  your script consists, of say six functions, one of which solves a problem and the other five of which are auxiliary to it, it is probably not  a  good style  to put the five subsidiary functions inside a where clause of the main one.  It is usually better to make all six top  level  definitions, with the important one written first, say.</p> <p>There are several reasons for this.  First that  it  makes  the  program easier  to read, since it consists of six separate chunks of information rather than one big one.  Second that the  program  is  much  easier  to debug,  because  each  of  its functions can be exercised separately, on appropriate test data,  within  a  Miranda  session.   Third  that  this program structure is more robust for future development - for example if we later wish to add a second <code>main</code> function that  solves  a  different problem  by  using  the same five auxiliary functions in another way, we can do so without having to restructure any existing code.</p> <p>There is a temptation to use <code>where</code> to hide  information  that  is  not relevant at top-level.  This may be misguided (especially if it leads to code with large and complex where-clauses).  If you don't  wish  all  of your  functions  or  data  structures  to be \"visible\" from outside, the proper way to do this is to include a <code>%export</code> directive in the script.</p> <p>Note also that (in the current implementation) functions defined  inside a  \"where\" clause cannot have their types explicitly specified.  This is a further reason to avoid putting structure inside a where  clause  that does not logically have to be there.</p> <p>Specify the types of top level identifiers The Milner  type  discipline  is  an  impressive  advance  in  compiler technology.   It  is  also  a  trap  for  the unwary.  The fact that the Miranda compiler will accept several hundred lines  of  code  without  a single  type  specification,  and  correctly  infer the types of all the identifiers does NOT mean that it is sensible to write code with no type information.   (Compare:  compilers will also accept large programs with no comments in, but that doesn't make such programs sensible.)</p> <p>For other than fairly small scripts  it  is  good  style  to  insert  an explicit  specification  of  the  type of any top level identifier whose type  is  not  immediately   apparent   from   its   definition.    Type specifications look like this</p> <pre><code>    ack::num-&gt;num-&gt;num\n</code></pre> <p>says that <code>ack</code> is a function taking two numbers and returning a number. A type specification can occur anywhere in a script,  either  before  or after  the  definition of the corresponding identifier, but common sense suggests that the best place for it is  just  before  the  corresponding definition.   </p> <p>If in doubt it is always better to put in a type specification  than  to leave it out.  The compiler may not need this extra type information but human  beings  definitely  do.   The  extra  type  information   becomes particularly important when your code reaches the level of complexity at which you start to make type errors.</p> <p>If your script contains a type error it is unreasonable  to  expect  the compiler to correctly locate the real source of the error in the absence of explicit type declarations.  A type error means  different  parts  of your  code are inconsistent with one another in their use of identifiers - if you have not given the compiler any information about the  intended use  of  an  identifier,  you  cannot expect it to know which of several conflicting uses are the <code>wrong</code> ones.  In such a case it can only  tell you  that  something  is  wrong, and indicate the line on which it first deduced an inconsistency - which may be many lines later than the <code>real</code> error.   Explicit  type  declarations  make it much more likely that the compiler will spot the <code>real  error</code>  on  the  line  where  it  actually occurs.</p> <p>Code containing explicit type information is  also  incomparably  easier for other people to read.</p> <p>Use safe layout This is a point to do with the operation of the offside  rule.   It  is most  easily  explained  by means of an example.  Consider the following definition, here assumed to be part of a larger script</p> <pre><code>    hippo = (rhino - swan)/piglet\n            where\n            piglet = 17\n            rhino = 63\n            swan = 29\n</code></pre> <p>Some time after writing this we  carry  out  a  global  edit  to  expand <code>hippo' to</code>hippopotamus`.  The definition now looks like this.</p> <pre><code>    hippopotamus = (rhino - swan)/piglet\n            where\n            piglet = 17\n            rhino = 63\n            swan = 29\n</code></pre> <p>the where-clause has become offside, and the definition will  no  longer compile.   Worse,  it is possible (with a little ingenuity) to construct examples of layout where changing the length of an identifier will  move a  definition  from  one  level  of scope to another, so that the script still  compiles  but  now  has  a  different  meaning!!!   Replacing  an identifier by a shorter one can cause similar difficulties with layout.</p> <p>The layout of the <code>hippo</code> definition was unsafe, because  the  level  of indentation  depended on the length of an identifier.  There are several possible styles of <code>safe</code> layout.  The basic rule to follow is:</p> <pre><code>    Whenever a right hand side goes on for more than one line\n    (because it consists of a set of guarded  cases, or because it\n    carries a where clause, or just because it is an expression too\n    big to fit on one line), you should take a newline BEFORE\n    starting the rhs, and indent by some standard amount (not\n    depending on the width of the lhs).\n</code></pre> <p>There are two main styles of safe layout, depending on whether you  take the  newline  before  or  after the <code>=</code> of the definition.  Here are two possible safe layouts for the <code>hippo</code> definition</p> <pre><code>    hippo = \n    (rhino - swan)/piglet\n    where\n    piglet = 17\n    rhino = 63\n    swan = 29\n\n    hippo \n    = (rhino - swan)/piglet\n    where\n    piglet = 17\n    rhino = 63\n    swan = 29\n</code></pre> <p>The reason that either style can be  used  is  that  the  boundary,  for offside  purposes,  of  a right hand side, is set by the first symbol of the rhs itself, and not by the preceding <code>=</code> sign.</p> <p>Both of these layouts  have  the  property  that  the  parse  cannot  be affected  by  edits  which alter the lengths of one or more identifiers. Either of these layout styles also have the  advantage  that  successive levels of indentation can move to the right by a fixed step - this makes code easier to read and lessens the danger that your layout  will  `fall off'  the  right  hand  edge  of  the screen (although if you follow the advice given earlier about avoiding deeply nested block  structure  this is in any case unlikely to be a problem).</p> <p>It would be convenient if there was a program for  reformatting  Miranda scripts with a standard layout.  Apart from ensuring that the layout was <code>safe</code> in the above sense, it might make it easier for  people  to  read each  other's  code.   A  layout program of this kind may be provided in later releases of the system.</p> <p>Acknowledgement: The <code>hippopotamus</code> example (and the problem  of  unsafe layout) was first pointed out by Mark Longley of the University of Kent.</p> <p>Write order independent code When defining functions by pattern matching it is best (except in a few cases  where it leads to real clumsiness of expression) to make sure the patterns are mutually exclusive, so it does not matter in what order the cases are written.</p> <p>For the same reason it is better style to use sets of guards  which  are composed   of  mutually  exclusive  boolean  expressions.   The  keyword <code>otherwise</code> sometimes helps to make this less painful.</p> <p>By way of illustration of some of the issues here is a  good  definition of  a  function  <code>merge</code>  which combines two already sorted lists into a single sorted result, eliminating duplicates in the process</p> <pre><code>    merge [] y = y\n    merge (a:x) [] = (a:x)\n    merge (a:x) (b:y)\n    =  a:merge x (b:y), if a&lt;b\n    =  b:merge (a:x) y, if a&gt;b\n    =  a:merge x y, if a=b\n</code></pre> <p>First note the use of  mutually  exclusive  sets  of  patterns  (it  was tempting  to write <code>merge x [] = x</code> as the second case, but the above is probably better style).  Note also that we didn't use <code>otherwise</code> as the last  guard here because it would have spoiled the symmetry of the three tests.</p> <p>A related issue to these is that where  a  function  is  not  everywhere defined  on its argument type, it is good practice to insert an explicit error  case.   For  example  the  definition  given  in   the   standard environment for <code>hd</code>, the function which extracts the first element of a list, is</p> <pre><code>    hd (a:x) = a\n    hd [] = error \"hd []\"\n</code></pre> <p>Of course if a function is applied to an argument for which no  equation has  been  given, the Miranda system will print an error message anyway, but one advantage of putting in an explicit call to <code>error</code> is that  the programmer  gets  control  of the error message.  The other (and perhaps main) advantage  is  that  for  someone  else  reading  the  script,  it explicitly  documents  the  fact  that  a certain use of the function is considered an error.</p>"},{"location":"4/","title":"The Miranda command interpreter","text":"<p>The Miranda system is invoked from unix by the command</p> <pre><code>    mira [script]\n</code></pre> <p>where <code>script</code> (optional parameter) is the pathname of a file containing a  set of Miranda definitions.  If no script is specified a default name <code>script.m</code> is assumed.  The named script (script.m by  default)  becomes your current script, during the ensuing Miranda session.  You can change your \"current script\" during a session, but  at  any  time  there  is  a unique filename which is current.</p> <p>Note that a file containing a Miranda script is expected to have a  name ending  in  <code>.m</code>  and  the  <code>mira</code>  command  will  add this extension if missing.  So <code>mira stuff</code> will be interpreted as <code>mira stuff.m</code>.  It  is a  convenient  and  widely used convention that files containing program sources should have names indicating which language they are written in.</p> <p>The set of names in scope at any time are those of the  current  script, together  with the names of any scripts which it <code>includes</code> (see library directives) plus the names of the standard environment, which is  always in  scope.   The  current script may be an empty or non-existent file if you have not yet put any definitions in it.  In this case just the names of the standard environment will be in scope.</p> <p>The prompt <code>Miranda</code> indicates that  you  are  talking  to  the  Miranda interpreter.   This  activity  is  called  a  Miranda <code>session'`.  Each command should be typed on a single line, following the prompt,  and  is entered  by  hitting  return.  Any command not beginning with one of the special characters `/</code> <code>?</code>, or <code>!</code> is assumed to be an expression to be evaluated.  The following commands are available during a session.</p>"},{"location":"4/#exp","title":"'exp'","text":"<p>Any Miranda expression typed on a line by itself is evaluated, and  the value  is  printed  on the screen.  If the value is of type [char] it is printed literally, otherwise the special function <code>show</code> is  applied  to it to convert it to printable form.  Example Miranda sum[1..100] 5050 (response)</p> <p>There  is a special symbol $$ which is always set to the last expression evaluated.  So after the above command $$ will have the value 5050,  and this  can  be used in the next expression - e.g. <code>$$/2</code> will produce the response 2525 (and the value of <code>$$</code> is now 2525).</p>"},{"location":"4/#exp-pathname","title":"<code>exp &amp;&gt; pathname</code>","text":"<p>A background process is set up  to  evaluate  exp,  and  the  resulting output (including error messages, if any) sent to the designated file.</p>"},{"location":"4/#exp-pathname_1","title":"<code>exp &amp;&gt;&gt; pathname</code>","text":"<p>As  above,  except  that the output is appended to the designated file, instead of replacing its previous contents.</p>"},{"location":"4/#exp_1","title":"<code>exp ::</code>","text":"<p>Print the type of the expression (instead of the  value).   Useful  for investigating the type structure of a script.</p>"},{"location":"4/#_1","title":"<code>?</code>","text":"<p>Lists  all  identifiers  currently in scope, grouped by file of origin, starting with the standard environment.</p>"},{"location":"4/#identifiers","title":"<code>?identifier(s)</code>","text":"<p>Gives more information about any  identifier  defined  in  the  current environment  (namely  its  type  and the name of the file in which it is defined).   This  command  will  also  accept  a  list  of  identifiers, separated by spaces.</p>"},{"location":"4/#identifier","title":"<code>??identifier</code>","text":"<p>Opens the relevant source file at the definition of  identifier,  which may be any currently in scope.  Try for example ??map For  this and several other features to work Miranda must be configured to use an appropriate editor - the default is vi,  but  you  can  change this.   See  section  31 subheading 5 of this manual (\"How to change the default editor\").</p>"},{"location":"4/#command","title":"<code>!command</code>","text":"<p>Execute any UNIX shell command.</p>"},{"location":"4/#_2","title":"<code>!!</code>","text":"<p>Repeat last shell command.</p> <p>Note that the character <code>%</code> can be used in any Miranda session  command, including  a  <code>!</code>  command,  as  an abbreviation for the pathname of the current script.  So for example         !wc % does a word count on the current script.  (If for some reason  you  need to  include a literal % character in a command, you can escape it with a preceding backslash.)</p> <p>All  the  remaining  commands  begin  with  <code>/</code>.   Each of the following commands can be abbreviated to its first letter.</p>"},{"location":"4/#edit-also-e","title":"<code>/edit (also /e)</code>","text":"<p>Edit the current script.   Calls  up  the  currently  installed  editor (default vi, to change this see remark under ?? above).  On quitting the editor, if changes have been made  to  any  relevant  source  file,  the Miranda system automatically recompiles the current script and any other scripts on which it depends and which have been updated.</p>"},{"location":"4/#edit-pathname-also-e-pathname","title":"<code>/edit pathname (also /e pathname)</code>","text":"<p>Edit arbitrary script.  Note that the pathname should end in  <code>.m</code>  and that this will be added if missing.</p> <p>Note by the way that (on most UNIX-like systems) Miranda understands the commonly used <code>~</code> convention in pathnames.  That is ~/file means file in your home directory, and ~jack/file means file in jack's home directory.</p>"},{"location":"4/#file-also-f","title":"<code>/file (also /f)</code>","text":"<p>Print the name of file containing the current script.</p>"},{"location":"4/#file-pathname-also-f-pathname","title":"<code>/file pathname (also /f pathname)</code>","text":"<p>Change to new current  script.   Equivalent  to  quitting  the  Miranda system  and  reinvoking it with a new sourcefile.  Like /e, /f adds \".m\" to the end of the filename if missing.</p> <p>Important special case - reselecting the current script, eg by saying         /f % forces the current script to be RECOMPILED - this is  useful  if  script has errors and you wish to see the error messages again.</p>"},{"location":"4/#help-also-h","title":"<code>/help (also /h)</code>","text":"<p>Display summary of main available commands.  There are a few less used auxiliary commands, not covered here /aux (or /a) will summarise these.</p>"},{"location":"4/#man-also-m","title":"<code>/man (also /m)</code>","text":"<p>Enter online manual system.</p>"},{"location":"4/#quit-also-q","title":"<code>/quit (also /q)</code>","text":"<p>Quit the Miranda system.  Typing the end of file character  (control-D) also has this effect.</p> <p>Finally note that $- and $+ are allowed as notations  for  the  standard input  in  Miranda  expressions.   The  standard  input  as  a  list  of characters is denoted by <code>$-</code>.  As  a  simple  example,  evaluating  the expression         reverse $- causes  everything  typed  at the keyboard upto the next control-D to be echoed backwards.</p> <p>The notation <code>$+</code> also denotes the standard input, but as a sequence  of Miranda  expressions  (one  per  line),  and  returns their values.  For example         sum $+ reads a sequence of numeric expressions from  the  standard  input,  and returns the sum of their values.  See the manual section on reading with interpretation  (under  UNIX/Miranda  system  interface)   for   further information.</p>"},{"location":"5/","title":"SUMMARY OF MAIN AVAILABLE COMMANDS:","text":"<pre><code>exp             evaluate a Miranda expression\nexp &amp;&gt; file     send value of expression to file (background process)\nexp &amp;&gt;&gt; file    append value of expression to file (background process)\nexp ::          print type of exp\n?               list all identifiers currently in scope\n?identifier(s)  give more information about identifier(s)\n??identifier    open source file at definition of identifier\n!command        execute any UNIX shell command\n!!              repeat last shell command\n/edit           edit current script (default editor = vi or joe)\n/edit filename  edit filename\n/file           display filename of current script\n/file filename  change to new current script\n/help           display this command summary\n/man            ENTER ONLINE REFERENCE MANUAL (menu driven)\n/quit           quit the Miranda system\n\nNotes:-\neach \"/\" command can be abbreviated to its first letter - /e /f /h /m /q\n% is shorthand for the name of the current script (in commands)\nSpecial case - note that `/f %` forces recompilation of current script\n$$ is shorthand for the last expression evaluated (in expressions)\nFor a list of auxiliary commands say /aux\n</code></pre>"},{"location":"6/","title":"Remaining commands list","text":"<pre><code>LIST OF REMAINING COMMANDS:\n\n/aux  /a          print this list of auxiliary commands\n/cd [dirname]     change directory (defaults to home directory)\n/count (/nocount) switch on (off) statistics following each evaluation\n/dic              report size of dictionary for storing names etc\n/editor           report name of text editor used by ?? and /e commands\n/editor PROG      change resident editor to PROG (see below)             **\n/find id(s)       like `?ids` but look under original names of aliases\n/gc (/nogc)       switch on (off) garbage collection reports\n/heap             report size of heap\n/heap SIZE        set heap to SIZE cells\n/hush (/nohush)   switch off (on) prompts and other unnecessary feedback\n/list (/nolist)   (dis)enable listing of script to screen when compiling **\n/miralib          report absolute pathname of the directory miralib\n/recheck (/norecheck) (dis)enable busy checking for script updates       **\n/settings  /s     print current settings of flags\n/version  /v      print version information\n||...             lines beginning in `||` are ignored (comment facility)\n\nnotes:-\ncommands marked (**) are sticky, i.e. remembered for subsequent sessions\nif you don't like the resident editor choose another - recommended editors\ninclude - vi, joe, nano, pico, emacs - for more info see /man section 31(5)\n/recheck enables a check for update of any relevant source file before\nevery evaluation, instead of only after /e[dit] - appropriate if an\neditor window is kept open alongside the mira session window.\n</code></pre>"},{"location":"7/","title":"Expressions","text":"<p>In Miranda an expression denotes a  value.   Expressions  occur  in  two contexts,  but  have  the same(*) syntax in both situations.  First, the basic mode of operation of the Miranda command interpreter  is  that  it evaluates   expressions   typed   at  the  terminal  (these  are  called <code>command-level expressions</code>).   Second,  expressions  are  an  important syntactic  component  of  scripts  (because  scripts  are collections of definitions, and the right hand sides of  definitions  are  composed  of expressions).</p> <p>Expressions typed at the terminal are volatile - only by being made part of a script can an expression be saved for future use.</p> <p>An  expression  is  either  simple,  or  a  function  application, or an operator expression, or an operator.</p> <p>A simple expression is one of the following:</p> <pre><code>    Identifier, e.g. `x` (see separate manual entry)\n\n    Literal, e.g. `136` (see separate manual entry)\n\n    An operator section (see separate manual entry)\n\n    The keyword `show' or `readvals` (see separate manual entries)\n\n    A list, such as `[1,5,7,9]' or a `dotdot` list or a  list  comprehension\n    (see separate manual entry on iterative expressions).\n\n    A tuple, such as `(True,\"green\",37)`.  Tuples differ from lists in  that\n    they  can  have  components  of mixed type.  They are always enclosed in\n    round parentheses.  The empty tuple, which has no components, is written\n    `()`.   Otherwise,  a tuple must have at least two components - there is\n    no concept of a one-tuple.  Tuples  cannot  be  subscripted,  but  their\n    components  can  be  extracted  by  pattern matching.  Since there is no\n    concept of a one-tuple, the use of parentheses  for  grouping  does  not\n    conflict with their use for tuple formation.\n</code></pre> <p>Any expression enclosed in parentheses is a simple expression.</p> <p>Function application is denoted by juxtaposition, and is left associative, so e.g.</p> <pre><code>    f a b\n</code></pre> <p>denotes a curried function application  of  two  arguments.   (So  f  is really  a  function  of  one argument whose result is another function - thus <code>f a b</code> is actually parsed as <code>(f a) b</code> -  the  advantage  of  this arrangement  is  that  <code>f  a</code>  has  a  meaning in its own right, it is a partially applied version of f.)</p>"},{"location":"7/#operator-expressions-eg-5x-17","title":"Operator expressions e.g. <code>5*x-17</code>","text":"<p>There  are  a  variety of infix and prefix operators, of various binding powers (see manual entry on operators).  Note that function  application is more binding than any operator.</p> <p>An  operator  on  its  own  can be used as the name of the corresponding function, as shown in the following examples</p> <pre><code>    arith2_ops = [+,-,*,/,div,mod,^]\n    sum = foldr (+) 0\n</code></pre> <p>both of which are legal definitions.  Note  that  when  an  operator  is passed as a parameter it needs to be parenthesised, to force the correct parse.  An ambiguity arises in the case of <code>-</code> which has two meanings as an  operator  (infix  and prefix) - the convention is that <code>-</code> occurring alone always refers to the infix (i.e. dyadic) case.  The name <code>neg</code>  is provided  for  the  unary  minus  function,  as  part  of  the  standard environment.</p> <p>A formal syntax for expressions can  be  found  in  the  manual  section called <code>Formal syntax of Miranda scripts</code>.</p> <p>(*) Note  There  is  one  exception  to  the  rule  that  command  level expressions  have  the  same  syntax as expressions inside scripts - the notation <code>$$</code>, meaning the last expression evaluated, is allowed only in command level expressions.</p>"},{"location":"8/","title":"Operators and their binding powers","text":"<p>Here is a list of all prefix and infix operators, in order of increasing binding power.  Operators given on the same line are of the same binding power.  Prefix operators are identified as such in the  comments  -  all others are infix.</p> operator comments : ++ -- right associative \\/ associative &amp; associative ~ prefix &gt; &gt;= = ~= &lt;= &lt; continued relations allowed, eg 0div mod                    left associative ^ right associative . associative # prefix ! left associative $identifier $IDENTIFIER right associative"},{"location":"8/#brief-explanation-of-each-operator","title":"Brief explanation of each operator:","text":"<pre><code>:       prefix an element to a list, type *-&gt;[*]-&gt;[*]\n++ --   list concatenation, list subtraction, both of type [*]-&gt;[*]-&gt;[*]\n        A formal definition of list subtraction is given below.\n\\/  &amp;   logical `or', `and`, both of type bool-&gt;bool-&gt;bool\n~       logical negation, type bool-&gt;bool\n&gt; &gt;= = ~= &lt;= &lt;\n        comparison operators, all of type *-&gt;*-&gt;bool\n        Note that there is an ordering defined on every (non-function)\n        type.  In the case of numbers, characters and strings the order\n        is as you would expect, on other types it as an arbitrary but\n        reproducible ordering.  Equality on structured data is a test \n        for isomorphism.  (i.e. in LISP terms it is \"EQUAL\" not \"EQ\").\n        It is an error to test functions for equality or order.\n+ -     plus, minus, type num-&gt;num-&gt;num\n-       unary minus, type num-&gt;num\n        Note that in Miranda unary minus binds less tightly than\n        the multiplication and division operators.  This is the\n        usual algebraic convention, but is different from PASCAL.\n* / div mod\n        times, divide, integer divide, integer remainder, \n        all of type num-&gt;num-&gt;num\n        `/` can be applied to integers or fractional numbers, and\n        always gives a fractional result, so eg 6/2 is 3.0\n        div and mod can only be applied to integers and\n        give integer results, eg 7 div 2 is 3, 7 mod 2 is 1.\n        div and mod obey the following laws, for a b any integers\n        with b ~= 0\n        (i)  b * (a div b) + a mod b  =  a\n        (ii) if b&gt;0 then 0 &lt;= a mod b &lt; b\n             if b&lt;0 then b &lt; a mod b &lt;= 0\n^       `to the power of`, type num-&gt;num-&gt;num\n.       function composition, type (**-&gt;***)-&gt;(*-&gt;**)-&gt;*-&gt;***\n#       length of list, type [*]-&gt;num\n!       list subscripting, type [*]-&gt;num-&gt;*\n        note that the first element of a non-empty list x is x!0 and the\n        last element is x!(#x-1)\n$identifier $IDENTIFIER\n        do-it-yourself infix, `a $f b` is equivalent in all contexts to\n        `f a b`.  Also works for constructors of two or more arguments.\n\nNote on list subtraction\n Here is a formal definition of the `--` operator  in  Miranda.   It  is\ndefined  using  an  auxiliary  function `remove` which removes the first\noccurrence (if any) of a given item from a list.\n\n        x -- [] = x\n        x -- (b:y) = (remove b x) -- y\n        remove b [] = []\n        remove b (a:x) = x,            if a=b\n                       = a:remove b x, otherwise\n</code></pre>"},{"location":"9/","title":"Sections","text":"<p>An infix operator can be partially applied, by supplying  it  with  only one  of its operands, the result being a function of one argument.  Such expressions are always parenthesised, to avoid ambiguity, and are called <code>sections</code>.   Two  different  kinds  of sections (called presections and postsections) are possible since either the first or the second  operand can be supplied.</p> <p>An example of a presection is</p> <pre><code>        (1/)\n</code></pre> <p>which denotes the reciprocal function.  An example of a postsection is</p> <pre><code>        (/3)\n</code></pre> <p>which gives a concise notation for the <code>divide by three</code> function.  Note that  both of these examples are functions of type (num-&gt;num).  With one exception (see below) sections can be formed using any  infix  operator. Further  examples  are  (0:)  which is a function for prefixing lists of numbers with zero, and (^2) which is the square function.</p> <p>Sections  may  be  regarded  as  the  analogue  of  currying  for  infix operators.  They are a minor syntactic convenience, and  do  not  really add  any  power  to the language, since any function denoted in this way could have been introduced by explicit definition.  For  the  first  two examples given above we could have written, say</p> <pre><code>    reciprocal y = 1/y\n    divide_by_three x = x/3\n</code></pre> <p>and then used the function names, although this would have been somewhat more verbose.</p> <p>To summarise the conventions for infixes, taking infix  division  as  an example, note that the following expressions are all equivalent.</p> <pre><code>    a / b\n    (/) a b\n    (a /) b\n    (/ b) a\n</code></pre> <p>The usual  rules  about  operator  precedence  (see  manual  section  on operators)  apply  to sections.  For example we can write (ab+) but not (a+b), because <code>*' is more binding than</code>+`.  The latter example should have   been  written  ((a+b)*).   As  always  when  writing  complicated expressions, if there is any possibility of ambiguity it  is  better  to put in extra parentheses.</p> <p>Special case It is not possible to form a postsection in infix minus, because  of  a conflict of meaning with unary minus.  For example:</p> <pre><code>    (-b)\n</code></pre> <p>is  a  parenthesised  occurrence of negative b, not a section.  As a way round this there is a function <code>subtract</code> in  the  standard  environment with  the  definition:-  subtract x y = y - x.  This is a normal curried function, so we  can  write  (subtract  b)  to  get  the  function  that subtracts b from things.</p> <p>Presections in infix minus, such as (a-), cause no ambiguity.  There are no  problems  with infix plus because Miranda does not have a unary plus operator.</p> <p>Acknowledgement:</p> <p>The idea of sections is due  to  Richard  Bird  (of  Oxford  University Programming  Research Group) and David Wile (of USC Information Sciences Institute).</p>"}]}